[{"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1700771269", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1700771269", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 62980, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1700771269", "stars": 8977, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"id": 657012, "username": "drymonfidelia", "url": "https://www.v2ex.com/u/drymonfidelia", "website": "", "twitter": null, "psn": null, "github": null, "btc": null, "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/gravatar/017bcef6e642dbf067e17838a9cd447a?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/017bcef6e642dbf067e17838a9cd447a?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/017bcef6e642dbf067e17838a9cd447a?s=73&d=retro", "created": 1698662217, "last_modified": 1716639831}, "last_reply_by": "lmshl", "last_touched": 1717307816, "title": "要对单个 6.20TB 的超大 csv 文件保持顺序的情况下进行去除重复行，有什么好思路？显然不可能加载进内存", "url": "https://www.v2ex.com/t/1046023", "created": 1717251260, "deleted": 0, "content": "", "content_rendered": "", "last_modified": 1717251260, "replies": 56, "id": 1046023}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/4ea0/6fbc/770_large.png?m=1695370146", "name": "career", "avatar_normal": "https://cdn.v2ex.com/navatar/4ea0/6fbc/770_normal.png?m=1695370146", "title": "职场话题", "url": "https://www.v2ex.com/go/career", "topics": 17203, "footer": "", "header": "这里，我们聊聊那些工作中遇到的开心和不开心的事。", "title_alternative": "Career", "avatar_mini": "https://cdn.v2ex.com/navatar/4ea0/6fbc/770_mini.png?m=1695370146", "stars": 3140, "aliases": [], "root": false, "id": 770, "parent_node_name": "work"}, "member": {"id": 680304, "username": "Kathy1989", "url": "https://www.v2ex.com/u/Kathy1989", "website": null, "twitter": null, "psn": null, "github": null, "btc": null, "location": null, "tagline": null, "bio": null, "avatar_mini": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_mini.png?m=1715343271", "avatar_normal": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_normal.png?m=1715343271", "avatar_large": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_large.png?m=1715343271", "avatar_xlarge": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_xlarge.png?m=1715343271", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_xlarge.png?m=1715343271", "created": 1710400387, "last_modified": 1715343271}, "last_reply_by": "cuzv", "last_touched": 1717307993, "title": "你们有共情老板的情结吗？", "url": "https://www.v2ex.com/t/1046046", "created": 1717263037, "deleted": 0, "content": "作为员工，你会有共情老板的情结吗？\r\n例如“老板真不容易，花那么多钱开公司招人，他压力很大，我应该多体谅他。他心情不好 PUA 我时，我也应该理解他，并且在不加工资的情况下主动多加班。老板跟我一样上有老下有小，他 7x24 小时工作，而且他没工资，我 5x8 小时感到很惭愧”\r\n\r\n或者作为老板，你希望员工这样共情你吗？\r\n\r\n听老范节目说，以前在 F 盛的公司里，很多 40 岁的程序员被老板批得哭着从会议室走出来", "content_rendered": "作为员工，你会有共情老板的情结吗？<br />例如“老板真不容易，花那么多钱开公司招人，他压力很大，我应该多体谅他。他心情不好 PUA 我时，我也应该理解他，并且在不加工资的情况下主动多加班。老板跟我一样上有老下有小，他 7x24 小时工作，而且他没工资，我 5x8 小时感到很惭愧”<br /><br />或者作为老板，你希望员工这样共情你吗？<br /><br />听老范节目说，以前在 F 盛的公司里，很多 40 岁的程序员被老板批得哭着从会议室走出来", "last_modified": 1717291831, "replies": 44, "id": 1046046}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1650095340", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1650095340", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 219455, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1650095340", "stars": 4180, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"id": 573616, "username": "WalterHs", "url": "https://www.v2ex.com/u/WalterHs", "website": null, "twitter": null, "psn": null, "github": null, "btc": null, "location": null, "tagline": null, "bio": null, "avatar_mini": "https://cdn.v2ex.com/gravatar/d2a2d84ca95875087611d8a7159f24ff?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/d2a2d84ca95875087611d8a7159f24ff?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/d2a2d84ca95875087611d8a7159f24ff?s=73&d=retro", "created": 1645627580, "last_modified": 1645627580}, "last_reply_by": "sanshao124", "last_touched": 1717282475, "title": "燃气公司不同意帮我移表怎么办？", "url": "https://www.v2ex.com/t/1045990", "created": 1717238868, "deleted": 0, "content": "我最近要装修，因为户型的问题，我打算把厨房和阳台调换位置，这俩挨着，互为隔壁，中间是承重墙。\r\n原本的燃气立管和燃气表都在之前的厨房，现在厨房位置调整到隔壁之后需要把燃气表也移动过来（燃气公司的规定），装修前找了燃气公司的师傅过来看了说的没问题，过几天过去帮我移。\r\n但过来几周之后，装修已经进行到一半了，师傅又说需要再确认下，然后找了另一个师傅一起上门看了半天，最终跟我说这个不能移，并且说立管和燃气表都必须在厨房，但是立管是不能移动的，我这么装修会导致立管在客厅，燃气表在厨房，这个公司不允许。\r\n现在的问题是，装修已经进行一大半了，追责也没有意义，我只想知道到底还有没有什么办法解决这个问题，我肯定希望使用燃气，如果不能解决那么我可能会决定继续装修，但是就不使用燃气了，使用电磁炉和电热水器，买个质量好一点的，但不确定这样会不会有什么问题，谢谢各位。", "content_rendered": "我最近要装修，因为户型的问题，我打算把厨房和阳台调换位置，这俩挨着，互为隔壁，中间是承重墙。<br />原本的燃气立管和燃气表都在之前的厨房，现在厨房位置调整到隔壁之后需要把燃气表也移动过来（燃气公司的规定），装修前找了燃气公司的师傅过来看了说的没问题，过几天过去帮我移。<br />但过来几周之后，装修已经进行到一半了，师傅又说需要再确认下，然后找了另一个师傅一起上门看了半天，最终跟我说这个不能移，并且说立管和燃气表都必须在厨房，但是立管是不能移动的，我这么装修会导致立管在客厅，燃气表在厨房，这个公司不允许。<br />现在的问题是，装修已经进行一大半了，追责也没有意义，我只想知道到底还有没有什么办法解决这个问题，我肯定希望使用燃气，如果不能解决那么我可能会决定继续装修，但是就不使用燃气了，使用电磁炉和电热水器，买个质量好一点的，但不确定这样会不会有什么问题，谢谢各位。", "last_modified": 1717238868, "replies": 38, "id": 1045990}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1650095340", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1650095340", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 219455, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1650095340", "stars": 4180, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"id": 679472, "username": "v7eeaU2MLyWNvp", "url": "https://www.v2ex.com/u/v7eeaU2MLyWNvp", "website": "", "twitter": null, "psn": null, "github": null, "btc": null, "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/gravatar/97902f8f301dbd4c04ddbc8ca183b01b?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/97902f8f301dbd4c04ddbc8ca183b01b?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/97902f8f301dbd4c04ddbc8ca183b01b?s=73&d=retro", "created": 1709907545, "last_modified": 1716345290}, "last_reply_by": "v7eeaU2MLyWNvp", "last_touched": 1717276132, "title": "洗一次衣服，光洗涤剂的成本就要 1 块 5 了。。。你有什么洗涤剂推荐？", "url": "https://www.v2ex.com/t/1045977", "created": 1717235114, "deleted": 0, "content": "之前买的洗衣凝珠，成本算下来是 3 毛钱 1 颗。一次洗一桶，一桶用 1 颗。发现这类洗衣凝珠洗不干净，排汗衣洗过失去了吸汗效果。懂户外的知道我说啥就不废话了。\r\n\r\n后来经过各种折腾，反正希望恢复排汗衣的吸汗效果。逐步研究发现，一方面是衣服洗不干净，一方面是衣服有硅油预处理。\r\n\r\n后来遇到一款 dalli 的洗衣液，价钱很贵，一小桶 1.1L 特价的时候好像 35 块，官方说能用 20 次左右。德国产的，这算进口。这下来洗一次衣服的成本光洗涤剂就要 1 块 5 了。不过，这个东西洗的确实干净，我的排汗衣，洗过一次就恢复了，有硅油的经过两三次洗涤后，也恢复了。\r\n\r\n问题来了，这玩意确实贵啊，特价的时候 35 块，没碰上特价 有时候要 70 多。。。哎。。。人不能一棵树上吊死，也是来问问 V 友，你有啥推荐？\r\n\r\n避雷洗衣凝珠，我猜啊，3-5 毛钱一颗的洗衣凝珠都大差不差，工业化大生产下来，原料，成本，提纯度啥的各种成本压缩下来，清洁效果，我想你也能猜到。。。", "content_rendered": "<p>之前买的洗衣凝珠，成本算下来是 3 毛钱 1 颗。一次洗一桶，一桶用 1 颗。发现这类洗衣凝珠洗不干净，排汗衣洗过失去了吸汗效果。懂户外的知道我说啥就不废话了。</p>\n<p>后来经过各种折腾，反正希望恢复排汗衣的吸汗效果。逐步研究发现，一方面是衣服洗不干净，一方面是衣服有硅油预处理。</p>\n<p>后来遇到一款 dalli 的洗衣液，价钱很贵，一小桶 1.1L 特价的时候好像 35 块，官方说能用 20 次左右。德国产的，这算进口。这下来洗一次衣服的成本光洗涤剂就要 1 块 5 了。不过，这个东西洗的确实干净，我的排汗衣，洗过一次就恢复了，有硅油的经过两三次洗涤后，也恢复了。</p>\n<p>问题来了，这玩意确实贵啊，特价的时候 35 块，没碰上特价 有时候要 70 多。。。哎。。。人不能一棵树上吊死，也是来问问 V 友，你有啥推荐？</p>\n<p>避雷洗衣凝珠，我猜啊，3-5 毛钱一颗的洗衣凝珠都大差不差，工业化大生产下来，原料，成本，提纯度啥的各种成本压缩下来，清洁效果，我想你也能猜到。。。</p>\n", "last_modified": 1717235114, "replies": 30, "id": 1045977}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/03af/dbd6/63_large.png?m=1644490200", "name": "java", "avatar_normal": "https://cdn.v2ex.com/navatar/03af/dbd6/63_normal.png?m=1644490200", "title": "Java", "url": "https://www.v2ex.com/go/java", "topics": 5921, "footer": "", "header": "Sun 公司发明，被广泛使用的一门编程语言。", "title_alternative": "Java", "avatar_mini": "https://cdn.v2ex.com/navatar/03af/dbd6/63_mini.png?m=1644490200", "stars": 5599, "aliases": [], "root": false, "id": 63, "parent_node_name": "programming"}, "member": {"id": 479145, "username": "HikariLan", "url": "https://www.v2ex.com/u/HikariLan", "website": "https://www.minecraft.kim", "twitter": "", "psn": "", "github": "shaokeyibb", "btc": "", "location": "西安", "tagline": "兰草凋荡，星辰璀璨", "bio": "", "avatar_mini": "https://cdn.v2ex.com/avatar/c527/329c/479145_mini.png?m=1698024421", "avatar_normal": "https://cdn.v2ex.com/avatar/c527/329c/479145_normal.png?m=1698024421", "avatar_large": "https://cdn.v2ex.com/avatar/c527/329c/479145_large.png?m=1698024421", "avatar_xlarge": "https://cdn.v2ex.com/avatar/c527/329c/479145_xlarge.png?m=1698024421", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/c527/329c/479145_xlarge.png?m=1698024421", "avatar_xxxlarge": "https://cdn.v2ex.com/avatar/c527/329c/479145_xlarge.png?m=1698024421", "created": 1585228227, "last_modified": 1698024421}, "last_reply_by": "bug51", "last_touched": 1717307908, "title": "过去、现在和未来 —— Java 的现代化之路", "url": "https://www.v2ex.com/t/1046015", "created": 1717247767, "deleted": 0, "content": "# 过去、现在和未来 —— Java 的现代化之路\r\n\r\nJava ，一门广受赞誉，却又饱受诟病的语言，在从其诞生至今，便无时不刻的被于其他语言对比，有时候这种对比是空穴来风的诽谤，但更多的是对这门语言未来的担心，而近 10 年来涌现的一个又一个新生的程序语言更是让 Java 一次又一次地被推上风口浪尖，使公众一次又一次的质疑：Java ，是否真的停滞不前了？\r\n\r\n2024 年，从大街上随便抓一个 Java 程序员，询问其 Java 有哪些槽点，我相信你的这个下午大概是别想离开这个人的声音了 —— 从泛型不支持基本数据类型到各种各样令人抓耳挠腮的奇怪问题，你绝对可以听这个人滔滔不绝地说上一整天。那么这些问题 Java 官方知道吗？当然知道，他们在解决吗？ Ummm ，至少我们可以说，他们一直以来都正在积极的为解决这些问题而努力，并且有些槽点，其实早已在最新版本的 Java 中被解决。\r\n\r\n因此，本篇文章的目的，便是带领读者从过去走向现在，再走向未来，回顾并前瞻 Java 已经推出，或是即将推出的全新特性，这些特性再 Java 的历史中都扮演着决定性的作用，为 Java“赶 Go 超 Rust”贡献着自己的努力。\r\n\r\n碍于篇幅所限，我们将只重点提及几个 Java 语言史上的重大改动，而其他小的（但不代表不重要）更新，我们姑且一概掠过。若要了解 Java 从过去到现在全部的特性更新，也许你可以看看 OpenJDK 的 Java 特性提案索引页 [JEP 0: JEP Index]( https://openjdk.org/jeps/0)，了解更多。\r\n\r\n## Java8：Lambda 表达式和 Stream API\r\n\r\nJava 8 无论是从 JVM 层面的变动，还是 Java 语法和标准库的变动，都可以说是 Java 有史以来第一次大规模的增补，毋庸置疑的，这次更新也为 Java 带来了第二春，使之焕发新生，而其长达近 20 年的 LTS 支持，也使其成为了 Java 历史上使用率最高，最经久不衰的 Java 版本。\r\n\r\n在这次更新中，Java 自然是引入了全新且复杂的 Date & Time API ，看起来好像有点用但实际上很鸡肋的 Optional API 这类谈不上小但是也很难说重大的标准库修补。但是更为被人津津乐道，且在本人看来是 Java 8 最重要的两个更新，便是 Lambda 表达式和 Stream API 。\r\n\r\n### Lambda 表达式\r\n\r\n也许是考虑到兼容性，也许就是纯粹 Java 开发者懒，自 Java 7 以前，Java 虚拟机（ JVM ）基本没有什么重大改动，纵然 Java 语言已经引入了诸如自动拆装箱、参数化类型（泛型）这样的重大语言特性，JVM 依然不动如山，全靠 `javac` 衬托。\r\n\r\n然而到了 Java 7 ，天塌了。JVM 引入了一个全新的指令 `invokedynamic`，其可以在运行时动态的分派一个函数调用，这个指令最初并没有被 Java 语言本身所使用，相反，它的出现是为了解决基于 JVM 的动态类型语言（例如 Groovy ）在运行时由于 JVM 无法支持函数类型动态分派而导致的巨大性能问题。\r\n\r\n而这个指令第一次在 Java 语言中登场，便是神奇的 Lambda 表达式了。\r\n\r\n即使你不知道 Lambda 表达式，或者他背后的函数式接口，我相信你一定写过这样的代码：\r\n\r\n```java\r\nnew Thread(() -> Foo.bar()).start(); // 更好的一个写法其实是 new Thread(Foo::bar).start();\r\n```\r\n\r\n这很自然，就像你可能不会泛型编程，但一定也用过带泛型的 Java 容器一样。但如果我告诉你，在过去的 Java 版本中，人们只能这么写：\r\n\r\n```java\r\nnew Thread(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        Foo.bar();\r\n    }\r\n}).start();\r\n```\r\n\r\n是不是会有一种天然的碰见庞然大物的恐惧感。而事实上，在 Java 8 以前，函数式编程是不可能的，这主要源自于 Java 的一个语法缺陷：在 Java 中，函数（方法）不是一等公民。\r\n\r\n什么是“一等公民”？来看看在 JavaScript 中大家习以为常的一段代码：\r\n\r\n```javascript\r\nfunction foo(){\r\n  console.log(\"foo!\");\r\n}\r\n\r\nfunction bar(barFoo){\r\n  barFoo();\r\n}\r\n\r\nbar(foo);\r\n```\r\n\r\n最后一行中，我们为 `bar` 函数直接传入 `foo` 函数作为其实参，并在 `bar` 函数中调用这个函数。我们可以将一个函数（或者说，函数指针）作为参数传入到函数中，就像其他数据类型一样。\r\n\r\n但是 Java 是没有办法直接传入函数指针的，如果你了解 C# 的话，C# 用 `Delegate`（委托）机制解决这个问题，而 Java 则绕的更远一些，选择了 `Functional Interface`（函数式接口）作为其函数式编程的解决方案。那么，什么是函数式接口？\r\n\r\n通俗的来讲，任意一个仅有一个抽象方法的接口，都是函数式接口（无论其是否标注 `@FunctionalInterface` 注解），例如我们上边看到的 `Thread` 构造方法中的 `Runnable` 接口：\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Runnable {\r\n    /**\r\n     * When an object implementing interface <code>Runnable</code> is used\r\n     * to create a thread, starting the thread causes the object's\r\n     * <code>run</code> method to be called in that separately executing\r\n     * thread.\r\n     * <p>\r\n     * The general contract of the method <code>run</code> is that it may\r\n     * take any action whatsoever.\r\n     *\r\n     * @see     java.lang.Thread#run()\r\n     */\r\n    public abstract void run();\r\n}\r\n```\r\n\r\n这个接口只有一个名为 `run` 的抽象方法，并没有任何返回值。我们可以为需要函数式接口实例的地方传入 Lambda 表达式，在运行时，Lambda 表达式会被转换为对应函数式接口的实例，就像我们为 `Thread` 传入构造函数参数所做的那样一样。\r\n\r\n当然，请不要误解我的意思，并不是自 Java 8 引入函数式接口这个概念之后，才有了 `Runnable` 接口，相反，`Runnable` 接口古早有之，是函数式接口的概念被引入后，`Runnable` 也正巧成为了函数式接口的一部分。\r\n\r\n### Stream API\r\n\r\nLambda 表达式的一大创新之处，就是为在 Java 语言进行函数式编程提供了可能，由此，Stream （流） API 应运而生。这里所说的“流”并不是指 I/O 流，而是一种数据流动的管道。举个例子，现在有一个包含 10000 个数字的 `int` 数组：\r\n\r\n```java\r\nint[] array = new int[10000];\r\n```\r\n\r\n我想找出该数组中所有数字大于 5000 的数字，然后让他们加一个不大于 500 的随机数，最后求和。在不使用 Stream API 的情况下我们会这么写：\r\n\r\n```java\r\npublic int sumRandomNumber(int[] array, Random random){\r\n        int rst = 0;\r\n        for (int i : array) {\r\n            if (i > 5000) {\r\n                rst += i + random.nextInt(500);\r\n            }\r\n        }\r\n        return rst;\r\n    }\r\n```\r\n\r\n但如果有了 Stream API ，只需要一行代码就可以解决：\r\n\r\n```java\r\npublic int sumRandomNumberWithStreamAPI(int[] array, Random random) {\r\n        return Arrays.stream(array).filter(i -> i > 5000).map(i -> i + random.nextInt(500)).sum();\r\n    }\r\n```\r\n\r\n在上述代码中，我们通过调用 `Arrays.stream` 方法将 `array` 转换为一个 `IntStream` 流对象，然后顺次调用 `filter` 和 `map` 流中间方法，过滤和映射数据，最终调用 `sum` 流终结方法，获得求和结果。\r\n\r\n一种特定类型的数据经过流中间方法的加工处理，最终经过流终结方法收集为我们想要的形式，这极大地提高了开发效率，而在以前的 Java 中，想要达成这样的操作，会使代码变得极度复杂。\r\n\r\n## Project Loom：Java 迈向现代化的第一步\r\n\r\n相信各位对“Coroutine （协程）”这个名词一定不陌生，被称为“轻量级线程”的它，在 I/O 密集型的应用程序开发领域可谓是如日中天。所谓“协程”，便是一种用户态的线程，它们构建于线程之上，由用户程序负责调度，而不是操作系统。比起原生的操作系统线程，他更轻量，而比起 Event Loop （事件循环）的解决方案，它又能保证对用户程序足够透明，降低开发过程中的心智负担。\r\n\r\n许多现代语言都配备了协程的原生支持，尽管它们各自的实现方式并不相同，例如 Go 的 `Goroutine`，Kotlin 的 `Kotlin Coroutines` 或是 C++ 20 的 `Coroutines`。在早期版本的 Java 中，其实有一个名为“Green thread （绿色线程）”的协程实现，但因为各种原因，最终被替换回了现在的操作系统线程。\r\n\r\n但是我们确实需要协程，于是 2017 年，Project Loom 应运而生，它的使命就是为 Java 提供自己的有栈协程实现，早期被称为“Fiber （纤程）”，后被称为“Virtual thread （虚拟线程）”，经过两个大版本的预览，其终于在 Java 21 中正式推出，这意味着 Java 平台也拥有了自己的原生协程实现。\r\n\r\n于是现在，你可以通过 Thread 对象的静态工厂方法 `ofVirtual` 创建一个虚拟线程:\r\n\r\n```java\r\nThread.ofVirtual().start(()->{\r\n\t// some heavy IO stuff\r\n});\r\n```\r\n\r\n就是这么简单，如果你在用 Spring Boot 3 ，只需要一行配置便可以在你的项目中启用虚拟线程支持：\r\n\r\n```properties\r\nspring.threads.virtual.enabled=true\r\n```\r\n\r\n很简单对不？现在就去试试看吧，我保证带来的性能提升是立竿见影的。\r\n\r\n当然有关并发编程，另一个绕不开的话题便是异步编程了，Java 目前原生的异步编程由 `Future` 等对象支持，用起来不能说十分好用，只能说味同嚼蜡。在 Java 19 引入的 Structured Concurrency （结构化并发）事实上在一定程度上为异步编程提供了更好的解决方案，篇幅所限，在这里我们也不再展开。\r\n\r\n## Project Panama：外地人向本地人的妥协\r\n\r\n长期以来，Java 一直以“一次编写，到处运行”作为自己的卖点，然而很不幸的是，Java 没能向开发者提供所有他们想要的原材料，因此，开发者们决定自己做，最终，在各种 JNI 函数和 Unsafe 调用的狂轰滥炸下，Java 最终还是变成了“一次编写，到处调试”的样子。\r\n\r\nJNI 好用吗？我相信没人会说好用，不然也不可能会有 JNA 一类的库出现，JNI 看似提供了 Java 向 native 调用的接口，但实际上它完全不够灵活，无法在运行时根据程序的需要动态的链接不同的函数。自 Java 1.1 引入 JNI 开始，这个东西就基本没什么变化，大家只能捏着鼻子用这样一套并不好用的东西，或者只能叹叹气，然后另寻他法。\r\n\r\n再回过头来看看 Unsafe ，在过去版本的 Java 中，管理堆外内存是非常复杂且危险的，尤其是当我们通过 hacky 的方式获取 `sun.misc.Unsafe` 类实例，并使用其中的 `allocateMemory` 方法来分配堆外内存时。这意味着，我们需要手动管理这些堆外内存的分配和释放，一不小心，就可能造成 JVM 虚拟机和 GC 无法处理的内存泄漏。\r\n\r\n有些人可能会说：JVM 本来就不希望你使用堆外内存，你为什么要这么用，这不是自找没趣吗？但是很遗憾的是，有时要想获得高性能的数据吞吐或是确保数据的一致性，我们不得不这么做，例如在 Java 中使用 `mmap`, CAS ，或是设置内存屏障。在 Java 8 ，如果你想设置一个操作系统级别的重量级锁，你可以使用 `LockSupport.park`；自 Java 9 开始，如果你想对一个对象中的字段 CAS 写入，则可以用 `VarHandle.compareAndSet` 方法；但是其他 JVM 未能提供的操作，也许你只能像使用 JNI 一样，绕一个大圈，或是看看社区上有没有已经做好的，也许可能充满各种漏洞的小玩具。\r\n\r\n但是事情还是需要解决的，最终这场争端以 Java 这个外地人向本地人的妥协而告终：Project Panama 应运而生。经过三个大版本的预览，Project Panama 的一个重要特性，The Foreign Function & Memory (FFM) API 终于在 Java 22 正式落地。FFM API 有什么用？首先，它可以提供灵活的本地库访问：\r\n\r\n```java\r\nLinker linker = Linker.nativeLinker();\r\nSymbolLookup stdlib = linker.defaultLookup();\r\nMethodHandle strlen = linker.downcallHandle(\r\n    stdlib.find(\"strlen\").orElseThrow(),\r\n    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\r\n);\r\n\r\ntry (Arena arena = Arena.ofConfined()) {\r\n    MemorySegment cString = arena.allocateFrom(\"Hello\");\r\n    long len = (long)strlen.invokeExact(cString); // 5\r\n}\r\n```\r\n\r\n上述代码创建了一个操作系统标准库的链接器，在其中查找 `strlen` 函数并以一个从 JVM 创建的堆外字符串作为参数执行，获取结果。在这个过程中，还需要告诉 JVM 函数和参数的内存布局，以便 JVM 可以正确传入他们。\r\n\r\n接下来，FFM API 向我们提供了更适合 Java 宝宝的堆外内存 API ，Arena ，你可以通过这种方式创建一个会自动被 GC 清理的堆外内存：\r\n\r\n```java\r\nMemorySegment segment = Arena.ofAuto().allocate(100, 1);\r\n...\r\nsegment = null; // the segment region becomes available for deallocation after this point\r\n```\r\n\r\n或者，你可以直接创建一个基于作用域的堆外内存，并使用 `try-with-resource` 语法包裹，只要离开 `try` 作用域，则分配的堆外内存会被自动释放：\r\n\r\n```java\r\nMemorySegment segment = null;\r\ntry (Arena arena = Arena.ofConfined()) {\r\n    segment = arena.allocate(100);\r\n    ...\r\n} // segment region deallocated here\r\nsegment.get(ValueLayout.JAVA_BYTE, 0); // throws IllegalStateException\r\n```\r\n\r\n别忘了 `mmap`，现在 FFM API 可以直接提供这种支持，只需要调用 `FileChannel.map` 方法即可：\r\n\r\n``` java\r\nArena arena = Arena.ofAuto();\r\ntry {\r\n    try (FileChannel channel = FileChannel.open(Path.of(\"large_file\"), StandardOpenOption.READ)) {\r\n        MemorySegment segment = channel.map(FileChannel.MapMode.READ_ONLY, 0, FILE_SIZE, arena);\r\n        // use segment in your way\r\n    }\r\n} catch (IOException e) {\r\n    throw new RuntimeException(e);\r\n}\r\n```\r\n\r\n是不是简简又单单呢？有了 FFM API 这把瑞士军刀，相信以后 Java 能做的事情会更有趣和疯狂。\r\n\r\n## Project Valhalla：走向未来\r\n\r\n至此，我们已经介绍完了 Java 走向现代化三座大山中已经落地的前两座，如你所见的是，他们每一个都充满诱惑，十分大胆，令 Java 焕发新生，但是 Project Valhalla 将带给我们的，比前面我讲过的那些特性更加疯狂，更加颠覆：为 Java 引入值类型对象，补上长久以来 Java 泛型编程的缺陷，并为 JVM 虚拟机提供运行时可见的泛型参数。\r\n\r\n让我们先来回忆一下泛型的前世今生：泛型于 Java 1.5 被首次引入，其更官方、也更直观的名称应该是 Parameterized Type （参数化类型），其允许将类型作为类或函数的参数提供，以便于更好的进行类型检查或是根据不同的泛型特化代码实现，然而后者并不被 Java 泛型所支持，因为 Java 泛型采用的方案于 C++, Go, Rust 这些语言的泛型方案有本质不同：Java 的泛型只是编译器语法糖，在运行时并没有影响代码执行，这意味着，当你在 C++ 中使用 `Vector<bool>` 和 `Vector<int>` 时，C++ 编译器事实上会生产两个不同版本的 `Vector` 类（这也是其名称“模板”的由来），但 Java 并不会改变这一点，`List<Boolean>` 和 `List<Integer>` 和其未泛化原始类型 `List` 没有任何差别，编译器会在需要提供或返回泛型参数时帮你做类型安全检查或自动类型转换，而 JVM 不会感知到泛型的存在。\r\n\r\n泛化泛型和具化泛型的争端从未停止，本文也无心讨论此两者之间各自的优劣，但是不可否认是，泛化泛型确实为 Java 引入了一个难以逾越的语法鸿沟：那就是参数化类型无法接受基本数据类型作为参数，这意味着在 C# 程序员严重看起来十分正常的代码：\r\n\r\n```c#\r\nList<int> list = new List<>();\r\n```\r\n\r\n在 Java 中是不可能的。而长久以来，Java 程序员只能被迫在需要将基本数据类型放入集合的场景下进退两难：要么把 `int` 装箱成 `Integer`，忍受额外的对象创建开销；要么自行构建，或者使用各种工具库提供的特化集合类型（例如 `IntArrayList`, `DoubleArrayList` 等）。而事实上，这种语法鸿沟在 Java 中由来已久，例如 `switch` 语句不支持 `double` 等类型，`instanceof` 关键字不支持针对基本数据类型的模式匹配等，颇令新手疑惑，好在在最近的版本（ Java 23 ）中，[这些问题都逐步得到完善]( https://openjdk.org/jeps/455)，进入预览的流程。\r\n\r\n再回过头来看看基本数据类型的装箱机制，这实际上是十分不明智的，因为基本数据类型这种可能被程序大量使用的数据，他们本应将其数值直接存储到内存中，而不是被包装一个含有比他们实际内容更为复杂的对象和对象头，这无疑增加了系统的内存压力。而参数化类型对基本数据类型的缺位更是加剧了这一问题。\r\n\r\n为此，Project Valhalla 横空出世，直指这些痛点问题，并推出了它们的解决方案：值类型和通用泛型。\r\n\r\n在未来的 Java 版本中，我们将可以通过 `value class` 标识创建一个值类型类：\r\n\r\n```java\r\nvalue record Color(byte red, byte green, byte blue) {} // 值记录类型\r\n```\r\n\r\n这种类型没有对象头，其 `hashCode` 直接据其所含字段计算，这同时也意味着，对值类型进行 `==` 比较将会比较其值，而不是其地址。在未来，所有的基本数据类型包装类都会被升级为这种值类型。而原本的类型将会被称为 Identity class ，意为具有身份的类型。\r\n\r\n而通用泛型（这是一个早前叫法，但我觉得放到这里更直观，所以接着沿用下来）将允许我们在未来在泛型中直接使用基本数据类型作为泛型参数，而这种实现有可能依然是通过自动拆装箱实现的。\r\n\r\n如果你恰巧用过 Java 16 及以上的版本，你可能会发现有一个新特性和上述特性有点类似，那就是 Record （记录）类型，该特性允许你通过简单的语法创建一个不可变的 POJO 对象，并为其实现 `equals`/`hashCode`/`toString` 方法和构造函数，而不必由你手动实现，或是使用额外的 `@lombok.Data` 和 `@lombok.AllArgsConstructor`注解：\r\n\r\n```java\r\nrecord Point(int x, int y) { } // 通过 new Point(0, 0) 构造，通过 point.x()/point.y() 访问\r\n```\r\n\r\n但实际上，record 和 value class 是有本质区别的。Record 本质上还是一个对象，他依然是一个特殊的语法糖，并没有改变对象的本质；而 value class 则彻底颠覆了 Java 原有的对象模型。\r\n\r\n除此之外，Project Valhalla 还有一些很有意思的提案，例如为 JVM 添加可 null 和非 null 类型，就将 C# 和 Kotlin 所做的那样；亦或者在运行时保留泛型参数，提供特化类型的实现等。\r\n\r\n最后要说的是，Project Valhalla 的相关提案仍在不断更新，早在草案时期，相关提案就已被推翻重置了多次，因此对于该提案的相关描述在未来可能会是不准确的，希望读者悉知。\r\n\r\n## 引用\r\n\r\n- [JEP 444: Virtual Threads (openjdk.org)]( https://openjdk.org/jeps/444)\r\n\r\n- [JEP 454: Foreign Function & Memory API (openjdk.org)]( https://openjdk.org/jeps/454)\r\n\r\n- [JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (openjdk.org)]( https://openjdk.org/jeps/471)\r\n\r\n- [java.lang.foreign (Java SE 22 & JDK 22) (oracle.com)]( https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html)\r\n\r\n- [Arena (Java SE 22 & JDK 22) (oracle.com)]( https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html)\r\n\r\n- [FileChannel (Java SE 22 & JDK 22) (oracle.com)]( https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long))\r\n\r\n- [Project Valhalla (openjdk.org)]( https://openjdk.org/projects/valhalla/)\r\n\r\n- [JEP 395: Records (openjdk.org)]( https://openjdk.org/jeps/395)\r\n\r\n- [JEP 401: Value Classes and Objects (Preview) (openjdk.org)]( https://openjdk.org/jeps/401)\r\n\r\n- [JEP 402: Enhanced Primitive Boxing (Preview) (openjdk.org)]( https://openjdk.org/jeps/402)\r\n\r\n- [JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview) (openjdk.org)]( https://openjdk.org/jeps/455)", "content_rendered": "<h1>过去、现在和未来 —— Java 的现代化之路</h1>\n<p>Java ，一门广受赞誉，却又饱受诟病的语言，在从其诞生至今，便无时不刻的被于其他语言对比，有时候这种对比是空穴来风的诽谤，但更多的是对这门语言未来的担心，而近 10 年来涌现的一个又一个新生的程序语言更是让 Java 一次又一次地被推上风口浪尖，使公众一次又一次的质疑：Java ，是否真的停滞不前了？</p>\n<p>2024 年，从大街上随便抓一个 Java 程序员，询问其 Java 有哪些槽点，我相信你的这个下午大概是别想离开这个人的声音了 —— 从泛型不支持基本数据类型到各种各样令人抓耳挠腮的奇怪问题，你绝对可以听这个人滔滔不绝地说上一整天。那么这些问题 Java 官方知道吗？当然知道，他们在解决吗？ Ummm ，至少我们可以说，他们一直以来都正在积极的为解决这些问题而努力，并且有些槽点，其实早已在最新版本的 Java 中被解决。</p>\n<p>因此，本篇文章的目的，便是带领读者从过去走向现在，再走向未来，回顾并前瞻 Java 已经推出，或是即将推出的全新特性，这些特性再 Java 的历史中都扮演着决定性的作用，为 Java“赶 Go 超 Rust”贡献着自己的努力。</p>\n<p>碍于篇幅所限，我们将只重点提及几个 Java 语言史上的重大改动，而其他小的（但不代表不重要）更新，我们姑且一概掠过。若要了解 Java 从过去到现在全部的特性更新，也许你可以看看 OpenJDK 的 Java 特性提案索引页 <a href=\"https://openjdk.org/jeps/0\" rel=\"nofollow\">JEP 0: JEP Index</a>，了解更多。</p>\n<h2>Java8：Lambda 表达式和 Stream API</h2>\n<p>Java 8 无论是从 JVM 层面的变动，还是 Java 语法和标准库的变动，都可以说是 Java 有史以来第一次大规模的增补，毋庸置疑的，这次更新也为 Java 带来了第二春，使之焕发新生，而其长达近 20 年的 LTS 支持，也使其成为了 Java 历史上使用率最高，最经久不衰的 Java 版本。</p>\n<p>在这次更新中，Java 自然是引入了全新且复杂的 Date &amp; Time API ，看起来好像有点用但实际上很鸡肋的 Optional API 这类谈不上小但是也很难说重大的标准库修补。但是更为被人津津乐道，且在本人看来是 Java 8 最重要的两个更新，便是 Lambda 表达式和 Stream API 。</p>\n<h3>Lambda 表达式</h3>\n<p>也许是考虑到兼容性，也许就是纯粹 Java 开发者懒，自 Java 7 以前，Java 虚拟机（ JVM ）基本没有什么重大改动，纵然 Java 语言已经引入了诸如自动拆装箱、参数化类型（泛型）这样的重大语言特性，JVM 依然不动如山，全靠 <code>javac</code> 衬托。</p>\n<p>然而到了 Java 7 ，天塌了。JVM 引入了一个全新的指令 <code>invokedynamic</code>，其可以在运行时动态的分派一个函数调用，这个指令最初并没有被 Java 语言本身所使用，相反，它的出现是为了解决基于 JVM 的动态类型语言（例如 Groovy ）在运行时由于 JVM 无法支持函数类型动态分派而导致的巨大性能问题。</p>\n<p>而这个指令第一次在 Java 语言中登场，便是神奇的 Lambda 表达式了。</p>\n<p>即使你不知道 Lambda 表达式，或者他背后的函数式接口，我相信你一定写过这样的代码：</p>\n<pre><code class=\"language-java\">new Thread(() -&gt; Foo.bar()).start(); // 更好的一个写法其实是 new Thread(Foo::bar).start();\n</code></pre>\n<p>这很自然，就像你可能不会泛型编程，但一定也用过带泛型的 Java 容器一样。但如果我告诉你，在过去的 Java 版本中，人们只能这么写：</p>\n<pre><code class=\"language-java\">new Thread(new Runnable() {\n    @Override\n    public void run() {\n        Foo.bar();\n    }\n}).start();\n</code></pre>\n<p>是不是会有一种天然的碰见庞然大物的恐惧感。而事实上，在 Java 8 以前，函数式编程是不可能的，这主要源自于 Java 的一个语法缺陷：在 Java 中，函数（方法）不是一等公民。</p>\n<p>什么是“一等公民”？来看看在 JavaScript 中大家习以为常的一段代码：</p>\n<pre><code class=\"language-javascript\">function foo(){\n  console.log(\"foo!\");\n}\n\nfunction bar(barFoo){\n  barFoo();\n}\n\nbar(foo);\n</code></pre>\n<p>最后一行中，我们为 <code>bar</code> 函数直接传入 <code>foo</code> 函数作为其实参，并在 <code>bar</code> 函数中调用这个函数。我们可以将一个函数（或者说，函数指针）作为参数传入到函数中，就像其他数据类型一样。</p>\n<p>但是 Java 是没有办法直接传入函数指针的，如果你了解 C# 的话，C# 用 <code>Delegate</code>（委托）机制解决这个问题，而 Java 则绕的更远一些，选择了 <code>Functional Interface</code>（函数式接口）作为其函数式编程的解决方案。那么，什么是函数式接口？</p>\n<p>通俗的来讲，任意一个仅有一个抽象方法的接口，都是函数式接口（无论其是否标注 <code>@FunctionalInterface</code> 注解），例如我们上边看到的 <code>Thread</code> 构造方法中的 <code>Runnable</code> 接口：</p>\n<pre><code class=\"language-java\">@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used\n     * to create a thread, starting the thread causes the object's\n     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing\n     * thread.\n     * &lt;p&gt;\n     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n</code></pre>\n<p>这个接口只有一个名为 <code>run</code> 的抽象方法，并没有任何返回值。我们可以为需要函数式接口实例的地方传入 Lambda 表达式，在运行时，Lambda 表达式会被转换为对应函数式接口的实例，就像我们为 <code>Thread</code> 传入构造函数参数所做的那样一样。</p>\n<p>当然，请不要误解我的意思，并不是自 Java 8 引入函数式接口这个概念之后，才有了 <code>Runnable</code> 接口，相反，<code>Runnable</code> 接口古早有之，是函数式接口的概念被引入后，<code>Runnable</code> 也正巧成为了函数式接口的一部分。</p>\n<h3>Stream API</h3>\n<p>Lambda 表达式的一大创新之处，就是为在 Java 语言进行函数式编程提供了可能，由此，Stream （流） API 应运而生。这里所说的“流”并不是指 I/O 流，而是一种数据流动的管道。举个例子，现在有一个包含 10000 个数字的 <code>int</code> 数组：</p>\n<pre><code class=\"language-java\">int[] array = new int[10000];\n</code></pre>\n<p>我想找出该数组中所有数字大于 5000 的数字，然后让他们加一个不大于 500 的随机数，最后求和。在不使用 Stream API 的情况下我们会这么写：</p>\n<pre><code class=\"language-java\">public int sumRandomNumber(int[] array, Random random){\n        int rst = 0;\n        for (int i : array) {\n            if (i &gt; 5000) {\n                rst += i + random.nextInt(500);\n            }\n        }\n        return rst;\n    }\n</code></pre>\n<p>但如果有了 Stream API ，只需要一行代码就可以解决：</p>\n<pre><code class=\"language-java\">public int sumRandomNumberWithStreamAPI(int[] array, Random random) {\n        return Arrays.stream(array).filter(i -&gt; i &gt; 5000).map(i -&gt; i + random.nextInt(500)).sum();\n    }\n</code></pre>\n<p>在上述代码中，我们通过调用 <code>Arrays.stream</code> 方法将 <code>array</code> 转换为一个 <code>IntStream</code> 流对象，然后顺次调用 <code>filter</code> 和 <code>map</code> 流中间方法，过滤和映射数据，最终调用 <code>sum</code> 流终结方法，获得求和结果。</p>\n<p>一种特定类型的数据经过流中间方法的加工处理，最终经过流终结方法收集为我们想要的形式，这极大地提高了开发效率，而在以前的 Java 中，想要达成这样的操作，会使代码变得极度复杂。</p>\n<h2>Project Loom：Java 迈向现代化的第一步</h2>\n<p>相信各位对“Coroutine （协程）”这个名词一定不陌生，被称为“轻量级线程”的它，在 I/O 密集型的应用程序开发领域可谓是如日中天。所谓“协程”，便是一种用户态的线程，它们构建于线程之上，由用户程序负责调度，而不是操作系统。比起原生的操作系统线程，他更轻量，而比起 Event Loop （事件循环）的解决方案，它又能保证对用户程序足够透明，降低开发过程中的心智负担。</p>\n<p>许多现代语言都配备了协程的原生支持，尽管它们各自的实现方式并不相同，例如 Go 的 <code>Goroutine</code>，Kotlin 的 <code>Kotlin Coroutines</code> 或是 C++ 20 的 <code>Coroutines</code>。在早期版本的 Java 中，其实有一个名为“Green thread （绿色线程）”的协程实现，但因为各种原因，最终被替换回了现在的操作系统线程。</p>\n<p>但是我们确实需要协程，于是 2017 年，Project Loom 应运而生，它的使命就是为 Java 提供自己的有栈协程实现，早期被称为“Fiber （纤程）”，后被称为“Virtual thread （虚拟线程）”，经过两个大版本的预览，其终于在 Java 21 中正式推出，这意味着 Java 平台也拥有了自己的原生协程实现。</p>\n<p>于是现在，你可以通过 Thread 对象的静态工厂方法 <code>ofVirtual</code> 创建一个虚拟线程:</p>\n<pre><code class=\"language-java\">Thread.ofVirtual().start(()-&gt;{\n\t// some heavy IO stuff\n});\n</code></pre>\n<p>就是这么简单，如果你在用 Spring Boot 3 ，只需要一行配置便可以在你的项目中启用虚拟线程支持：</p>\n<pre><code class=\"language-properties\">spring.threads.virtual.enabled=true\n</code></pre>\n<p>很简单对不？现在就去试试看吧，我保证带来的性能提升是立竿见影的。</p>\n<p>当然有关并发编程，另一个绕不开的话题便是异步编程了，Java 目前原生的异步编程由 <code>Future</code> 等对象支持，用起来不能说十分好用，只能说味同嚼蜡。在 Java 19 引入的 Structured Concurrency （结构化并发）事实上在一定程度上为异步编程提供了更好的解决方案，篇幅所限，在这里我们也不再展开。</p>\n<h2>Project Panama：外地人向本地人的妥协</h2>\n<p>长期以来，Java 一直以“一次编写，到处运行”作为自己的卖点，然而很不幸的是，Java 没能向开发者提供所有他们想要的原材料，因此，开发者们决定自己做，最终，在各种 JNI 函数和 Unsafe 调用的狂轰滥炸下，Java 最终还是变成了“一次编写，到处调试”的样子。</p>\n<p>JNI 好用吗？我相信没人会说好用，不然也不可能会有 JNA 一类的库出现，JNI 看似提供了 Java 向 native 调用的接口，但实际上它完全不够灵活，无法在运行时根据程序的需要动态的链接不同的函数。自 Java 1.1 引入 JNI 开始，这个东西就基本没什么变化，大家只能捏着鼻子用这样一套并不好用的东西，或者只能叹叹气，然后另寻他法。</p>\n<p>再回过头来看看 Unsafe ，在过去版本的 Java 中，管理堆外内存是非常复杂且危险的，尤其是当我们通过 hacky 的方式获取 <code>sun.misc.Unsafe</code> 类实例，并使用其中的 <code>allocateMemory</code> 方法来分配堆外内存时。这意味着，我们需要手动管理这些堆外内存的分配和释放，一不小心，就可能造成 JVM 虚拟机和 GC 无法处理的内存泄漏。</p>\n<p>有些人可能会说：JVM 本来就不希望你使用堆外内存，你为什么要这么用，这不是自找没趣吗？但是很遗憾的是，有时要想获得高性能的数据吞吐或是确保数据的一致性，我们不得不这么做，例如在 Java 中使用 <code>mmap</code>, CAS ，或是设置内存屏障。在 Java 8 ，如果你想设置一个操作系统级别的重量级锁，你可以使用 <code>LockSupport.park</code>；自 Java 9 开始，如果你想对一个对象中的字段 CAS 写入，则可以用 <code>VarHandle.compareAndSet</code> 方法；但是其他 JVM 未能提供的操作，也许你只能像使用 JNI 一样，绕一个大圈，或是看看社区上有没有已经做好的，也许可能充满各种漏洞的小玩具。</p>\n<p>但是事情还是需要解决的，最终这场争端以 Java 这个外地人向本地人的妥协而告终：Project Panama 应运而生。经过三个大版本的预览，Project Panama 的一个重要特性，The Foreign Function &amp; Memory (FFM) API 终于在 Java 22 正式落地。FFM API 有什么用？首先，它可以提供灵活的本地库访问：</p>\n<pre><code class=\"language-java\">Linker linker = Linker.nativeLinker();\nSymbolLookup stdlib = linker.defaultLookup();\nMethodHandle strlen = linker.downcallHandle(\n    stdlib.find(\"strlen\").orElseThrow(),\n    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n);\n\ntry (Arena arena = Arena.ofConfined()) {\n    MemorySegment cString = arena.allocateFrom(\"Hello\");\n    long len = (long)strlen.invokeExact(cString); // 5\n}\n</code></pre>\n<p>上述代码创建了一个操作系统标准库的链接器，在其中查找 <code>strlen</code> 函数并以一个从 JVM 创建的堆外字符串作为参数执行，获取结果。在这个过程中，还需要告诉 JVM 函数和参数的内存布局，以便 JVM 可以正确传入他们。</p>\n<p>接下来，FFM API 向我们提供了更适合 Java 宝宝的堆外内存 API ，Arena ，你可以通过这种方式创建一个会自动被 GC 清理的堆外内存：</p>\n<pre><code class=\"language-java\">MemorySegment segment = Arena.ofAuto().allocate(100, 1);\n...\nsegment = null; // the segment region becomes available for deallocation after this point\n</code></pre>\n<p>或者，你可以直接创建一个基于作用域的堆外内存，并使用 <code>try-with-resource</code> 语法包裹，只要离开 <code>try</code> 作用域，则分配的堆外内存会被自动释放：</p>\n<pre><code class=\"language-java\">MemorySegment segment = null;\ntry (Arena arena = Arena.ofConfined()) {\n    segment = arena.allocate(100);\n    ...\n} // segment region deallocated here\nsegment.get(ValueLayout.JAVA_BYTE, 0); // throws IllegalStateException\n</code></pre>\n<p>别忘了 <code>mmap</code>，现在 FFM API 可以直接提供这种支持，只需要调用 <code>FileChannel.map</code> 方法即可：</p>\n<pre><code class=\"language-java\">Arena arena = Arena.ofAuto();\ntry {\n    try (FileChannel channel = FileChannel.open(Path.of(\"large_file\"), StandardOpenOption.READ)) {\n        MemorySegment segment = channel.map(FileChannel.MapMode.READ_ONLY, 0, FILE_SIZE, arena);\n        // use segment in your way\n    }\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n</code></pre>\n<p>是不是简简又单单呢？有了 FFM API 这把瑞士军刀，相信以后 Java 能做的事情会更有趣和疯狂。</p>\n<h2>Project Valhalla：走向未来</h2>\n<p>至此，我们已经介绍完了 Java 走向现代化三座大山中已经落地的前两座，如你所见的是，他们每一个都充满诱惑，十分大胆，令 Java 焕发新生，但是 Project Valhalla 将带给我们的，比前面我讲过的那些特性更加疯狂，更加颠覆：为 Java 引入值类型对象，补上长久以来 Java 泛型编程的缺陷，并为 JVM 虚拟机提供运行时可见的泛型参数。</p>\n<p>让我们先来回忆一下泛型的前世今生：泛型于 Java 1.5 被首次引入，其更官方、也更直观的名称应该是 Parameterized Type （参数化类型），其允许将类型作为类或函数的参数提供，以便于更好的进行类型检查或是根据不同的泛型特化代码实现，然而后者并不被 Java 泛型所支持，因为 Java 泛型采用的方案于 C++, Go, Rust 这些语言的泛型方案有本质不同：Java 的泛型只是编译器语法糖，在运行时并没有影响代码执行，这意味着，当你在 C++ 中使用 <code>Vector&lt;bool&gt;</code> 和 <code>Vector&lt;int&gt;</code> 时，C++ 编译器事实上会生产两个不同版本的 <code>Vector</code> 类（这也是其名称“模板”的由来），但 Java 并不会改变这一点，<code>List&lt;Boolean&gt;</code> 和 <code>List&lt;Integer&gt;</code> 和其未泛化原始类型 <code>List</code> 没有任何差别，编译器会在需要提供或返回泛型参数时帮你做类型安全检查或自动类型转换，而 JVM 不会感知到泛型的存在。</p>\n<p>泛化泛型和具化泛型的争端从未停止，本文也无心讨论此两者之间各自的优劣，但是不可否认是，泛化泛型确实为 Java 引入了一个难以逾越的语法鸿沟：那就是参数化类型无法接受基本数据类型作为参数，这意味着在 C# 程序员严重看起来十分正常的代码：</p>\n<pre><code class=\"language-c#\">List&lt;int&gt; list = new List&lt;&gt;();\n</code></pre>\n<p>在 Java 中是不可能的。而长久以来，Java 程序员只能被迫在需要将基本数据类型放入集合的场景下进退两难：要么把 <code>int</code> 装箱成 <code>Integer</code>，忍受额外的对象创建开销；要么自行构建，或者使用各种工具库提供的特化集合类型（例如 <code>IntArrayList</code>, <code>DoubleArrayList</code> 等）。而事实上，这种语法鸿沟在 Java 中由来已久，例如 <code>switch</code> 语句不支持 <code>double</code> 等类型，<code>instanceof</code> 关键字不支持针对基本数据类型的模式匹配等，颇令新手疑惑，好在在最近的版本（ Java 23 ）中，<a href=\"https://openjdk.org/jeps/455\" rel=\"nofollow\">这些问题都逐步得到完善</a>，进入预览的流程。</p>\n<p>再回过头来看看基本数据类型的装箱机制，这实际上是十分不明智的，因为基本数据类型这种可能被程序大量使用的数据，他们本应将其数值直接存储到内存中，而不是被包装一个含有比他们实际内容更为复杂的对象和对象头，这无疑增加了系统的内存压力。而参数化类型对基本数据类型的缺位更是加剧了这一问题。</p>\n<p>为此，Project Valhalla 横空出世，直指这些痛点问题，并推出了它们的解决方案：值类型和通用泛型。</p>\n<p>在未来的 Java 版本中，我们将可以通过 <code>value class</code> 标识创建一个值类型类：</p>\n<pre><code class=\"language-java\">value record Color(byte red, byte green, byte blue) {} // 值记录类型\n</code></pre>\n<p>这种类型没有对象头，其 <code>hashCode</code> 直接据其所含字段计算，这同时也意味着，对值类型进行 <code>==</code> 比较将会比较其值，而不是其地址。在未来，所有的基本数据类型包装类都会被升级为这种值类型。而原本的类型将会被称为 Identity class ，意为具有身份的类型。</p>\n<p>而通用泛型（这是一个早前叫法，但我觉得放到这里更直观，所以接着沿用下来）将允许我们在未来在泛型中直接使用基本数据类型作为泛型参数，而这种实现有可能依然是通过自动拆装箱实现的。</p>\n<p>如果你恰巧用过 Java 16 及以上的版本，你可能会发现有一个新特性和上述特性有点类似，那就是 Record （记录）类型，该特性允许你通过简单的语法创建一个不可变的 POJO 对象，并为其实现 <code>equals</code>/<code>hashCode</code>/<code>toString</code> 方法和构造函数，而不必由你手动实现，或是使用额外的 <code>@lombok.Data</code> 和 <code>@lombok.AllArgsConstructor</code>注解：</p>\n<pre><code class=\"language-java\">record Point(int x, int y) { } // 通过 new Point(0, 0) 构造，通过 point.x()/point.y() 访问\n</code></pre>\n<p>但实际上，record 和 value class 是有本质区别的。Record 本质上还是一个对象，他依然是一个特殊的语法糖，并没有改变对象的本质；而 value class 则彻底颠覆了 Java 原有的对象模型。</p>\n<p>除此之外，Project Valhalla 还有一些很有意思的提案，例如为 JVM 添加可 null 和非 null 类型，就将 C# 和 Kotlin 所做的那样；亦或者在运行时保留泛型参数，提供特化类型的实现等。</p>\n<p>最后要说的是，Project Valhalla 的相关提案仍在不断更新，早在草案时期，相关提案就已被推翻重置了多次，因此对于该提案的相关描述在未来可能会是不准确的，希望读者悉知。</p>\n<h2>引用</h2>\n<ul>\n<li>\n<p><a href=\"https://openjdk.org/jeps/444\" rel=\"nofollow\">JEP 444: Virtual Threads (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/454\" rel=\"nofollow\">JEP 454: Foreign Function &amp; Memory API (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/471\" rel=\"nofollow\">JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html\" rel=\"nofollow\">java.lang.foreign (Java SE 22 &amp; JDK 22) (oracle.com)</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html\" rel=\"nofollow\">Arena (Java SE 22 &amp; JDK 22) (oracle.com)</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long)\" rel=\"nofollow\">FileChannel (Java SE 22 &amp; JDK 22) (oracle.com)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/projects/valhalla/\" rel=\"nofollow\">Project Valhalla (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/395\" rel=\"nofollow\">JEP 395: Records (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/401\" rel=\"nofollow\">JEP 401: Value Classes and Objects (Preview) (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/402\" rel=\"nofollow\">JEP 402: Enhanced Primitive Boxing (Preview) (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/455\" rel=\"nofollow\">JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview) (openjdk.org)</a></p>\n</li>\n</ul>\n", "last_modified": 1717247767, "replies": 27, "id": 1046015}, {"node": {"avatar_large": "/static/img/node_default_large.png", "name": "taobao", "avatar_normal": "/static/img/node_default_normal.png", "title": "淘宝", "url": "https://www.v2ex.com/go/taobao", "topics": 364, "footer": null, "header": null, "title_alternative": "淘宝", "avatar_mini": "/static/img/node_default_mini.png", "stars": 69, "aliases": [], "root": false, "id": 726, "parent_node_name": null}, "member": {"id": 589794, "username": "nightnotlate", "url": "https://www.v2ex.com/u/nightnotlate", "website": null, "twitter": null, "psn": null, "github": null, "btc": null, "location": null, "tagline": null, "bio": null, "avatar_mini": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_mini.png?m=1660731939", "avatar_normal": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_normal.png?m=1660731939", "avatar_large": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_large.png?m=1660731939", "avatar_xlarge": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_xlarge.png?m=1660731939", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_xlarge.png?m=1660731939", "avatar_xxxlarge": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_xlarge.png?m=1660731939", "created": 1659317123, "last_modified": 1660731939}, "last_reply_by": "herozzm", "last_touched": 1717308031, "title": "后知后觉发现某宝很多评价是假的", "url": "https://www.v2ex.com/t/1046085", "created": 1717297103, "deleted": 0, "content": "一个款式的包 ，不同品牌，不同店铺。\n发现评价居然是一样的，来自同样的人，同样的文字，同样的照片。\n刷一个店铺我能理解。\n但是给不同店铺刷评价，是什么道理呢？\n一 平台所为？（应该不至于吧）\n二 刚好两家店铺请到了同一个机器人？\n还是别的原因呢\n求教", "content_rendered": "一个款式的包 ，不同品牌，不同店铺。<br />发现评价居然是一样的，来自同样的人，同样的文字，同样的照片。<br />刷一个店铺我能理解。<br />但是给不同店铺刷评价，是什么道理呢？<br />一 平台所为？（应该不至于吧）<br />二 刚好两家店铺请到了同一个机器人？<br />还是别的原因呢<br />求教", "last_modified": 1717301594, "replies": 21, "id": 1046085}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/6f49/22f4/18_large.png?m=1650127482", "name": "shanghai", "avatar_normal": "https://cdn.v2ex.com/navatar/6f49/22f4/18_normal.png?m=1650127482", "title": "上海", "url": "https://www.v2ex.com/go/shanghai", "topics": 3544, "footer": "", "header": "", "title_alternative": "Shanghai", "avatar_mini": "https://cdn.v2ex.com/navatar/6f49/22f4/18_mini.png?m=1650127482", "stars": 2407, "aliases": [], "root": false, "id": 18, "parent_node_name": "cn"}, "member": {"id": 390543, "username": "devfeng", "url": "https://www.v2ex.com/u/devfeng", "website": "", "twitter": "", "psn": "", "github": "", "btc": "", "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/avatar/23d1/9b45/390543_mini.png?m=1671274594", "avatar_normal": "https://cdn.v2ex.com/avatar/23d1/9b45/390543_normal.png?m=1671274594", "avatar_large": "https://cdn.v2ex.com/avatar/23d1/9b45/390543_large.png?m=1671274594", "created": 1552029856, "last_modified": 1671274594}, "last_reply_by": "daquandiao2", "last_touched": 1717269188, "title": "不打算买房，公积金要提取出来吗", "url": "https://www.v2ex.com/t/1045980", "created": 1717236051, "deleted": 0, "content": "在上海，没有近期买房的打算，公积金账户里有 17w ，补充公积金账户里还有 7w 。看了下上海的公积金贷款政策，账户里有 3w 就可以贷满 80w 了？所以多出来的部分是不是提出来比较好？顺便问下现在提取只能租房提取吗？每个月额度好像只有 5000 ？", "content_rendered": "在上海，没有近期买房的打算，公积金账户里有 17w ，补充公积金账户里还有 7w 。看了下上海的公积金贷款政策，账户里有 3w 就可以贷满 80w 了？所以多出来的部分是不是提出来比较好？顺便问下现在提取只能租房提取吗？每个月额度好像只有 5000 ？", "last_modified": 1717236051, "replies": 20, "id": 1045980}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/38af/8613/176_large.png?m=1644885960", "name": "car", "avatar_normal": "https://cdn.v2ex.com/navatar/38af/8613/176_normal.png?m=1644885960", "title": "汽车", "url": "https://www.v2ex.com/go/car", "topics": 2178, "footer": "", "header": "关于买车、开车及汽车文化的技术讨论", "title_alternative": "Car", "avatar_mini": "https://cdn.v2ex.com/navatar/38af/8613/176_mini.png?m=1644885960", "stars": 1871, "aliases": [], "root": false, "id": 176, "parent_node_name": "life"}, "member": {"id": 525865, "username": "busier", "url": "https://www.v2ex.com/u/busier", "website": "", "twitter": null, "psn": null, "github": null, "btc": null, "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/avatar/a5e4/86ac/525865_mini.png?m=1715302588", "avatar_normal": "https://cdn.v2ex.com/avatar/a5e4/86ac/525865_normal.png?m=1715302588", "avatar_large": "https://cdn.v2ex.com/avatar/a5e4/86ac/525865_large.png?m=1715302588", "avatar_xlarge": "https://cdn.v2ex.com/avatar/a5e4/86ac/525865_xlarge.png?m=1715302588", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/a5e4/86ac/525865_xlarge.png?m=1715302588", "avatar_xxxlarge": "https://cdn.v2ex.com/avatar/a5e4/86ac/525865_xlarge.png?m=1715302588", "created": 1609127616, "last_modified": 1715302588}, "last_reply_by": "Stoney", "last_touched": 1717307882, "title": "突发奇想自动驾驶如果完美实现可以用来解决临停问题", "url": "https://www.v2ex.com/t/1046057", "created": 1717287527, "deleted": 0, "content": "只要自动驾驶在目标附近绕圈不停开就行了，费不了多少电\r\n\r\n有些金贵路段停车收费每小时 10 元以上，临停那点时间，在怎么样也不会开出 10 元电费吧", "content_rendered": "只要自动驾驶在目标附近绕圈不停开就行了，费不了多少电<br /><br />有些金贵路段停车收费每小时 10 元以上，临停那点时间，在怎么样也不会开出 10 元电费吧", "last_modified": 1717287527, "replies": 19, "id": 1046057}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/3cef/96dc/949_large.png?m=1614702882", "name": "nas", "avatar_normal": "https://cdn.v2ex.com/navatar/3cef/96dc/949_normal.png?m=1614702882", "title": "NAS", "url": "https://www.v2ex.com/go/nas", "topics": 1969, "footer": "", "header": "关于网络存储设备的讨论", "title_alternative": "NAS", "avatar_mini": "https://cdn.v2ex.com/navatar/3cef/96dc/949_mini.png?m=1614702882", "stars": 2192, "aliases": [], "root": false, "id": 949, "parent_node_name": "hardware"}, "member": {"id": 76564, "username": "sldaniel", "url": "https://www.v2ex.com/u/sldaniel", "website": "", "twitter": "", "psn": "", "github": "", "btc": "", "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/gravatar/3ce1307c08fc447d8528126665f2f43e?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/3ce1307c08fc447d8528126665f2f43e?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/3ce1307c08fc447d8528126665f2f43e?s=73&d=retro", "created": 1412917305, "last_modified": 1705061854}, "last_reply_by": "bytesfold", "last_touched": 1717261493, "title": "有没有什么低成本的单盘位 NAS 推荐", "url": "https://www.v2ex.com/t/1046010", "created": 1717246006, "deleted": 0, "content": "arm 平台的是不是能便宜点\r\n\r\n主要用来当异地备份的目地的:\r\n\r\n1.支持 wireguard 和 webdav 就行,这俩应该不难,能装 linux 就行,况且都有 go 版本的二进制包.\r\n\r\n2.带盘位;用 usb 硬盘盒之类的方式容易坏硬盘,供电也不行.\r\n\r\n3.不要太大\r\n\r\n4.支持 docker 加分,非必须\r\n\r\n最便宜的现成方案有什么推荐吗?", "content_rendered": "<p>arm 平台的是不是能便宜点</p>\n<p>主要用来当异地备份的目地的:</p>\n<p>1.支持 wireguard 和 webdav 就行,这俩应该不难,能装 linux 就行,况且都有 go 版本的二进制包.</p>\n<p>2.带盘位;用 usb 硬盘盒之类的方式容易坏硬盘,供电也不行.</p>\n<p>3.不要太大</p>\n<p>4.支持 docker 加分,非必须</p>\n<p>最便宜的现成方案有什么推荐吗?</p>\n", "last_modified": 1717292661, "replies": 19, "id": 1046010}]