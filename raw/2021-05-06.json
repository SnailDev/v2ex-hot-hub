[{"node": {"avatar_large": "https://cdn.v2ex.com/navatar/a5e0/0132/146_large.png?m=1594135486", "name": "js", "avatar_normal": "https://cdn.v2ex.com/navatar/a5e0/0132/146_normal.png?m=1594135486", "title": "JavaScript", "url": "https://www.v2ex.com/go/js", "topics": 2570, "footer": "", "header": "JavaScript (sometimes abbreviated JS) is a prototype-based scripting language that is dynamic, weakly typed and has first-class functions.", "title_alternative": "JavaScript", "avatar_mini": "https://cdn.v2ex.com/navatar/a5e0/0132/146_mini.png?m=1594135486", "stars": 2592, "aliases": [], "root": false, "id": 146, "parent_node_name": "programming"}, "member": {"username": "BoringTu", "website": "https://boringtu.com", "github": "boringtu", "psn": "", "avatar_normal": "https://cdn.v2ex.com/gravatar/2f6cc0bdcaeb803a4c46e836f15b7c94?s=24&d=retro", "bio": "", "url": "https://www.v2ex.com/u/BoringTu", "tagline": "", "twitter": "", "created": 1523427136, "avatar_large": "https://cdn.v2ex.com/gravatar/2f6cc0bdcaeb803a4c46e836f15b7c94?s=24&d=retro", "avatar_mini": "https://cdn.v2ex.com/gravatar/2f6cc0bdcaeb803a4c46e836f15b7c94?s=24&d=retro", "location": "", "btc": "", "id": 307764}, "last_reply_by": "LancerComet", "last_touched": 1620295277, "title": "为什么你们要选择 TypeScript？", "url": "https://www.v2ex.com/t/775169", "created": 1620283503, "content": "我只是不明白为啥这么多人会选择 ts ？理由是啥啊？ ts 出来的那年我就关注了，但所有的理由在我看来都是莫名其妙的观点，但这些年怎么还用的人越来越多了？\r\n咱就说脑回路很神奇的把本身弱类型为优势的 JavaScript，套了一层强类型的壳的这步操作我就看不懂了，这是图啥呢？这样代码写着不难受么？那你直接用 Java 写然后编译成 JavaScript 不好么？\r\n网上有很多人说，用 ts 可以减少因类型导致的错误。大哥，你是个程序员，你连自己写的代码是怎么跑的都不知道的话，转行好吗？我十一年的程序员了，js 写了 11 年，js 的其他高级语言我也都研究过，包括 ts，但现在只用 es6 和 coffee2，我怎么就一次都没碰到过我连变量背后的值类型导致的 bug 呢？", "content_rendered": "我只是不明白为啥这么多人会选择 ts ？理由是啥啊？ ts 出来的那年我就关注了，但所有的理由在我看来都是莫名其妙的观点，但这些年怎么还用的人越来越多了？<br />咱就说脑回路很神奇的把本身弱类型为优势的 JavaScript，套了一层强类型的壳的这步操作我就看不懂了，这是图啥呢？这样代码写着不难受么？那你直接用 Java 写然后编译成 JavaScript 不好么？<br />网上有很多人说，用 ts 可以减少因类型导致的错误。大哥，你是个程序员，你连自己写的代码是怎么跑的都不知道的话，转行好吗？我十一年的程序员了，js 写了 11 年，js 的其他高级语言我也都研究过，包括 ts，但现在只用 es6 和 coffee2，我怎么就一次都没碰到过我连变量背后的值类型导致的 bug 呢？", "last_modified": 1620283503, "replies": 133, "id": 775169}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/fc22/1309/181_large.png?m=1608240651", "name": "travel", "avatar_normal": "https://cdn.v2ex.com/navatar/fc22/1309/181_normal.png?m=1608240651", "title": "旅行", "url": "https://www.v2ex.com/go/travel", "topics": 624, "footer": "", "header": "你会把上大学的学费用来环游世界么？", "title_alternative": "Travel", "avatar_mini": "https://cdn.v2ex.com/navatar/fc22/1309/181_mini.png?m=1608240651", "stars": 719, "aliases": [], "root": false, "id": 181, "parent_node_name": "life"}, "member": {"username": "cjw1115", "website": "", "github": "", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/e317/22e7/248020_mini.png?m=1550572416", "bio": "", "url": "https://www.v2ex.com/u/cjw1115", "tagline": "", "twitter": "", "created": 1502415784, "avatar_large": "https://cdn.v2ex.com/avatar/e317/22e7/248020_mini.png?m=1550572416", "avatar_mini": "https://cdn.v2ex.com/avatar/e317/22e7/248020_mini.png?m=1550572416", "location": "", "btc": "", "id": 248020}, "last_reply_by": "FaiChou", "last_touched": 1620294373, "title": "特斯拉毛豆 3 顺利完成 4600 公里 深圳甘肃往返自驾", "url": "https://www.v2ex.com/t/775052", "created": 1620230789, "content": "接上贴，https://www.v2ex.com/t/772419?p=1 我买了个 osmo action 简单记录了一下整个行程。\r\n视频会在 b 站陆续更新。https://www.bilibili.com/video/BV1My4y1x7MT?share_source=copy_web \r\n\r\n### 去程 4 天，\r\n* 第一天，基本全开车了，深圳早上八点出发，晚上八点到长沙，高速上补了两次电，花费 110RMB\r\n* 第二天，早上再橘子洲逛了一早上，下午一点出发去岳阳看岳阳楼，晚上住在岳阳，超充不花钱\r\n* 第三天，岳阳早上 7 点出发，下午六点到西安，高速上补了两次电，花费 65RMB，晚上住西安，超级充电免费额度\r\n* 第四天，早上见了西安的朋友，一起吃东西，中午西安出发，晚上 7 点到家，高速上补电一次，花费 38RMB\r\n\r\n去程酒店加吃饭花了 1500 。过路费交了 1000 左右，总共花费 2700 左右。\r\n\r\n\r\n### 回程本来打算把车托运，自己坐飞机。但是...\r\n\r\n1. 托运加机票要 4500RMB，而且托运可能把车划伤，保险还不陪.\r\n2. 特斯拉超充免费\r\n3. 送了 45 天的 EAP\r\n4. 高速不收费\r\n5. 假期还有四天\r\n\r\n所以我又开回来了，回程就一直开车了，用了三天\r\n* 第一天，甘肃定西到湖北十堰，晚上住十堰，高速充电两次 45rmb, 晚上超充免费\r\n* 第二天，湖北十堰到湖南郴州，晚上住郴州, 高速充电两次 50RMB，晚上超充免费\r\n* 第三天，早上四点出发，早上 10 点到达深圳，高速补电一次 34RMB 。\r\n\r\n回程住酒店加吃饭花了 1000 。 总共花费 1200 左右。\r\n\r\n比托运划算多了，就是多花了两天时间，反正回深圳也是打游戏...", "content_rendered": "<p>接上贴，<a href=\"https://www.v2ex.com/t/772419?p=1\" rel=\"nofollow\">https://www.v2ex.com/t/772419?p=1</a> 我买了个 osmo action 简单记录了一下整个行程。\n视频会在 b 站陆续更新。<a href=\"https://www.bilibili.com/video/BV1My4y1x7MT?share_source=copy_web\" rel=\"nofollow\">https://www.bilibili.com/video/BV1My4y1x7MT?share_source=copy_web</a> </p>\n<h3>去程 4 天，</h3>\n<ul>\n<li>第一天，基本全开车了，深圳早上八点出发，晚上八点到长沙，高速上补了两次电，花费 110RMB</li>\n<li>第二天，早上再橘子洲逛了一早上，下午一点出发去岳阳看岳阳楼，晚上住在岳阳，超充不花钱</li>\n<li>第三天，岳阳早上 7 点出发，下午六点到西安，高速上补了两次电，花费 65RMB，晚上住西安，超级充电免费额度</li>\n<li>第四天，早上见了西安的朋友，一起吃东西，中午西安出发，晚上 7 点到家，高速上补电一次，花费 38RMB</li>\n</ul>\n<p>去程酒店加吃饭花了 1500 。过路费交了 1000 左右，总共花费 2700 左右。</p>\n<h3>回程本来打算把车托运，自己坐飞机。但是...</h3>\n<ol>\n<li>托运加机票要 4500RMB，而且托运可能把车划伤，保险还不陪.</li>\n<li>特斯拉超充免费</li>\n<li>送了 45 天的 EAP</li>\n<li>高速不收费</li>\n<li>假期还有四天</li>\n</ol>\n<p>所以我又开回来了，回程就一直开车了，用了三天</p>\n<ul>\n<li>第一天，甘肃定西到湖北十堰，晚上住十堰，高速充电两次 45rmb, 晚上超充免费</li>\n<li>第二天，湖北十堰到湖南郴州，晚上住郴州, 高速充电两次 50RMB，晚上超充免费</li>\n<li>第三天，早上四点出发，早上 10 点到达深圳，高速补电一次 34RMB 。</li>\n</ul>\n<p>回程住酒店加吃饭花了 1000 。 总共花费 1200 左右。</p>\n<p>比托运划算多了，就是多花了两天时间，反正回深圳也是打游戏...</p>\n", "last_modified": 1620231146, "replies": 94, "id": 775052}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/b789/2fb3/937_large.png?m=1584298330", "name": "zhihu", "avatar_normal": "https://cdn.v2ex.com/navatar/b789/2fb3/937_normal.png?m=1584298330", "title": "知乎", "url": "https://www.v2ex.com/go/zhihu", "topics": 270, "footer": "", "header": "知乎创建于 2010 年，是一个用户产生内容的问答社区", "title_alternative": "Zhihu", "avatar_mini": "https://cdn.v2ex.com/navatar/b789/2fb3/937_mini.png?m=1584298330", "stars": 81, "aliases": [], "root": false, "id": 937, "parent_node_name": "internet"}, "member": {"username": "Cassano", "website": null, "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/020c/daac/461815_mini.png?m=1577460505", "bio": null, "url": "https://www.v2ex.com/u/Cassano", "tagline": null, "twitter": null, "created": 1577460265, "avatar_large": "https://cdn.v2ex.com/avatar/020c/daac/461815_mini.png?m=1577460505", "avatar_mini": "https://cdn.v2ex.com/avatar/020c/daac/461815_mini.png?m=1577460505", "location": null, "btc": null, "id": 461815}, "last_reply_by": "loonie", "last_touched": 1620293107, "title": "为什么现在到处都在说拉垮，而且什么都能拉垮？还有什么不能拉垮的么？我觉得现在有些过度使用这个词汇了", "url": "https://www.v2ex.com/t/775084", "created": 1620266457, "content": "", "content_rendered": "", "last_modified": 1620276475, "replies": 61, "id": 775084}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1618811339", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1618811339", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 172113, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1618811339", "stars": 3219, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"username": "thOOr", "website": null, "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/gravatar/dda704ce4284ff26a260c7ce96c2c365?s=24&d=retro", "bio": null, "url": "https://www.v2ex.com/u/thOOr", "tagline": null, "twitter": null, "created": 1595493532, "avatar_large": "https://cdn.v2ex.com/gravatar/dda704ce4284ff26a260c7ce96c2c365?s=24&d=retro", "avatar_mini": "https://cdn.v2ex.com/gravatar/dda704ce4284ff26a260c7ce96c2c365?s=24&d=retro", "location": null, "btc": null, "id": 500490}, "last_reply_by": "felixwang", "last_touched": 1620291158, "title": "研二女慢性肾炎，前辈们能帮忙分析下我现在怎么做比较好吗。。未来想从事写代码的工作， 6 月毕设中期检查", "url": "https://www.v2ex.com/t/775003", "created": 1620210094, "content": "一个月前做了第一次 24h，今天刚做完第二次 24h，从 0.62g 升到了 0.86g 。这一个月来几乎每天跑步，keep 上累积了 60 公里了，没想到锻炼并没有让指标好看。。\r\n目前在北京，确实医疗资源丰富，但我并不太懂如何利用。\r\n希望前辈们能给些关于以下几个问题的任何建议，鞠躬：\r\n1.做肾穿的时间？\r\n\r\n中期前尽快做 or 中期结束做（ 6 月秋招提前批了应该） or 秋招找完工作做\r\n自己想到的一些点：\r\n1 ）早肾穿，可以早明确病理、早对症下药，少疑神疑鬼\r\n2 ）但目前 6 月中旬毕设中期检查的论文和答辩 ppt 都没开始制作，而且写论文之前还需要再做一些工作，担心肾穿手术会耽误中期导致延毕半年，是非常非常不想在实验室多待的\r\n3 ）肾病太受歧视了（ ps: 不能考公、考教师编，入职体检严的单位应该也难进去？前几天说北京统一一次入职体检结果可复用了，不知对我是利是弊），在校做难免会让同实验室同学和狗导师知道我的肾有不小的问题，人言可畏，可能对我的“找好工作和按时毕业”这两个目标带来潜在风险？\r\n\r\n2.关于秋招目标单位？\r\n\r\n985 本硕万金油专业，毕设项目软硬件都搞但搞的都很浅，被狗导师坑着接了需要填往届造假大坑的项目，没人带、没发论文，一直被项目恶心着，到现在身体还垮了。。。数据库、操作系统、计算机组成这些来不及自学了，跟科班比不了，做的项目是三维视觉检测有关的，师兄说相机厂的相机算法岗之类的会比较对口，但是被师姐说的 o v 两厂的竞争压力吓到了。。\r\n996 严重的部门和岗位肯定排除了（但是就我浅显的认知，叫得上名的很多厂其实特别严重的也没几家？大部分应该是大小周？我们实验室长期 8.5 10 6 。。。）\r\n追求稳定和福利保障（慢性肾病会伴随一生）的话，研究所这个选择如何？但我一直以来都想从事写代码的工作、并且跟优秀有活力的人共事，感觉更喜欢互联网的氛围（抛却福报的话）\r\n\r\n3.找工作及工作后要一直隐瞒自己有慢性肾病吗？\r\n\r\n这一点我没任何概念，也不知道瞒不瞒得住，要不要瞒\r\n\r\n有类似经历的前辈能不能讲一下自己是怎样一路伴随着这病走过来的？再次鞠躬！！", "content_rendered": "一个月前做了第一次 24h，今天刚做完第二次 24h，从 0.62g 升到了 0.86g 。这一个月来几乎每天跑步，keep 上累积了 60 公里了，没想到锻炼并没有让指标好看。。<br />目前在北京，确实医疗资源丰富，但我并不太懂如何利用。<br />希望前辈们能给些关于以下几个问题的任何建议，鞠躬：<br />1.做肾穿的时间？<br /><br />中期前尽快做 or 中期结束做（ 6 月秋招提前批了应该） or 秋招找完工作做<br />自己想到的一些点：<br />1 ）早肾穿，可以早明确病理、早对症下药，少疑神疑鬼<br />2 ）但目前 6 月中旬毕设中期检查的论文和答辩 ppt 都没开始制作，而且写论文之前还需要再做一些工作，担心肾穿手术会耽误中期导致延毕半年，是非常非常不想在实验室多待的<br />3 ）肾病太受歧视了（ ps: 不能考公、考教师编，入职体检严的单位应该也难进去？前几天说北京统一一次入职体检结果可复用了，不知对我是利是弊），在校做难免会让同实验室同学和狗导师知道我的肾有不小的问题，人言可畏，可能对我的“找好工作和按时毕业”这两个目标带来潜在风险？<br /><br />2.关于秋招目标单位？<br /><br />985 本硕万金油专业，毕设项目软硬件都搞但搞的都很浅，被狗导师坑着接了需要填往届造假大坑的项目，没人带、没发论文，一直被项目恶心着，到现在身体还垮了。。。数据库、操作系统、计算机组成这些来不及自学了，跟科班比不了，做的项目是三维视觉检测有关的，师兄说相机厂的相机算法岗之类的会比较对口，但是被师姐说的 o v 两厂的竞争压力吓到了。。<br />996 严重的部门和岗位肯定排除了（但是就我浅显的认知，叫得上名的很多厂其实特别严重的也没几家？大部分应该是大小周？我们实验室长期 8.5 10 6 。。。）<br />追求稳定和福利保障（慢性肾病会伴随一生）的话，研究所这个选择如何？但我一直以来都想从事写代码的工作、并且跟优秀有活力的人共事，感觉更喜欢互联网的氛围（抛却福报的话）<br /><br />3.找工作及工作后要一直隐瞒自己有慢性肾病吗？<br /><br />这一点我没任何概念，也不知道瞒不瞒得住，要不要瞒<br /><br />有类似经历的前辈能不能讲一下自己是怎样一路伴随着这病走过来的？再次鞠躬！！", "last_modified": 1620210094, "replies": 58, "id": 775003}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1618811339", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1618811339", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 172113, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1618811339", "stars": 3219, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"username": "Pogbag", "website": "shua1zh.github.io", "github": "", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/a49b/0fdd/300244_mini.png?m=1609399441", "bio": "", "url": "https://www.v2ex.com/u/Pogbag", "tagline": "", "twitter": "", "created": 1521078466, "avatar_large": "https://cdn.v2ex.com/avatar/a49b/0fdd/300244_mini.png?m=1609399441", "avatar_mini": "https://cdn.v2ex.com/avatar/a49b/0fdd/300244_mini.png?m=1609399441", "location": "", "btc": "", "id": 300244}, "last_reply_by": "kmyq", "last_touched": 1620295148, "title": "你们的 NAS 上都跑了什么服务", "url": "https://www.v2ex.com/t/775071", "created": 1620264103, "content": "机型：DS220+/10G RAM/4T+1T HDD\r\n系统：DSM 6.2.4\r\n\r\n下载：download station/玩物下载 /qBittorent\r\n\r\n影音：Emby/tinyMediaManager/AVDC\r\n\r\n同步：Cloud Sync 同步百度网盘\r\n\r\nDocker：chrome 浏览器 访问内网路由器用的\r\n\r\n虚拟机：装了 win7 卡的要死 鼠标掉帧\r\n\r\n求推荐一些好玩的", "content_rendered": "<p>机型：DS220+/10G RAM/4T+1T HDD\n系统：DSM 6.2.4</p>\n<p>下载：download station/玩物下载 /qBittorent</p>\n<p>影音：Emby/tinyMediaManager/AVDC</p>\n<p>同步：Cloud Sync 同步百度网盘</p>\n<p>Docker：chrome 浏览器 访问内网路由器用的</p>\n<p>虚拟机：装了 win7 卡的要死 鼠标掉帧</p>\n<p>求推荐一些好玩的</p>\n", "last_modified": 1620264103, "replies": 58, "id": 775071}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_large.png?m=1615111825", "name": "apple", "avatar_normal": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_normal.png?m=1615111825", "title": "Apple", "url": "https://www.v2ex.com/go/apple", "topics": 14763, "footer": "", "header": "设计了 <a href=\"/go/watch\">Apple Watch</a>，<a href=\"/go/ipad\">iPad</a>，<a href=\"/go/iphone\">iPhone</a>，<a href=\"/go/imac\">iMac</a> 及 <a href=\"/go/mbp\">MacBook Pro</a> 等电子产品的美国公司。", "title_alternative": "Apple", "avatar_mini": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_mini.png?m=1615111825", "stars": 1799, "aliases": [], "root": false, "id": 184, "parent_node_name": "hardware"}, "member": {"username": "intellectual", "website": "", "github": "", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/8a91/81fa/73451_mini.png?m=1464244435", "bio": "", "url": "https://www.v2ex.com/u/intellectual", "tagline": "", "twitter": "", "created": 1410326245, "avatar_large": "https://cdn.v2ex.com/avatar/8a91/81fa/73451_mini.png?m=1464244435", "avatar_mini": "https://cdn.v2ex.com/avatar/8a91/81fa/73451_mini.png?m=1464244435", "location": "", "btc": "", "id": 73451}, "last_reply_by": "lagoon", "last_touched": 1620294498, "title": "又一次因为键盘膜...", "url": "https://www.v2ex.com/t/775045", "created": 1620228832, "content": "- 我之前手机啊电脑啊一直不愿意贴膜带壳。\r\n- 之前看到过很多可笑的帖子，我甚至还发生过在某个帖子下面回复要贴膜，结果竟然会被人嘲讽，哎呦喂被使劲的嘲讽了一顿，当然这事不在 v2 发生，在 v2 没咋太水过。。。\r\n- 然后前前后后经历了，iPhone 被摔，键盘进灰，进水。前几次进水都还行，造成的伤害不大。就在今天下午，不巧水杯翻了，这次进水直接算是半残了。。。\r\n- 之前被嘲讽的那个帖子，人家义正严辞的说，电脑边放什么杯子。。。？\r\n- 一直也认为贴了膜肯定手感不好啊，影响散热啊，屏幕印子啊...没必要啊。什么厂家努力把厚度减小了 0.1mm ，结果你这种没品味的直接加了 1 个 mm 。但这次进水，直接告诉我，你个穷逼，贴膜吧，装你妹啊装。。。\r\n- 还有，之前蝶式键盘进灰双击等问题。蝶式键盘之前的旧键盘，我拆过，可以拆，没问题。蝶式之后，我之前看帖子说不建议个人拆蝶式键盘键帽，特别容易拆坏。然后就看到有大神说可以拆，然后晒出了成果。然后我自己一拆，果然就有一个键帽的脚直接磨损了，然后就松动了。。。看了一眼淘宝上卖配件的一个键 50，算了，凑合用吧，又不是不能用。这次的事我在 v2 别的帖子留过言，然后就有大神圈我说可以拆。。。\r\n- 。。。\r\n- 今天好气啊，再次提个醒，如果你跟我一样生活没有那么的仔细，不能像宝贝似的把苹果护着，也不是维修专业博士生的话。。。贴膜，带壳吧。。。生活一个小插曲就让人。。。😭😭😭\r\n- 哎，立马下单买了 5 张键盘膜，没手感就没手感吧，👴认了。。。", "content_rendered": "<ul>\n<li>我之前手机啊电脑啊一直不愿意贴膜带壳。</li>\n<li>之前看到过很多可笑的帖子，我甚至还发生过在某个帖子下面回复要贴膜，结果竟然会被人嘲讽，哎呦喂被使劲的嘲讽了一顿，当然这事不在 v2 发生，在 v2 没咋太水过。。。</li>\n<li>然后前前后后经历了，iPhone 被摔，键盘进灰，进水。前几次进水都还行，造成的伤害不大。就在今天下午，不巧水杯翻了，这次进水直接算是半残了。。。</li>\n<li>之前被嘲讽的那个帖子，人家义正严辞的说，电脑边放什么杯子。。。？</li>\n<li>一直也认为贴了膜肯定手感不好啊，影响散热啊，屏幕印子啊...没必要啊。什么厂家努力把厚度减小了 0.1mm ，结果你这种没品味的直接加了 1 个 mm 。但这次进水，直接告诉我，你个穷逼，贴膜吧，装你妹啊装。。。</li>\n<li>还有，之前蝶式键盘进灰双击等问题。蝶式键盘之前的旧键盘，我拆过，可以拆，没问题。蝶式之后，我之前看帖子说不建议个人拆蝶式键盘键帽，特别容易拆坏。然后就看到有大神说可以拆，然后晒出了成果。然后我自己一拆，果然就有一个键帽的脚直接磨损了，然后就松动了。。。看了一眼淘宝上卖配件的一个键 50，算了，凑合用吧，又不是不能用。这次的事我在 v2 别的帖子留过言，然后就有大神圈我说可以拆。。。</li>\n<li>。。。</li>\n<li>今天好气啊，再次提个醒，如果你跟我一样生活没有那么的仔细，不能像宝贝似的把苹果护着，也不是维修专业博士生的话。。。贴膜，带壳吧。。。生活一个小插曲就让人。。。😭😭😭</li>\n<li>哎，立马下单买了 5 张键盘膜，没手感就没手感吧，👴认了。。。</li>\n</ul>\n", "last_modified": 1620229096, "replies": 39, "id": 775045}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1620107083", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1620107083", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 44365, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1620107083", "stars": 7361, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"username": "polyang", "website": "", "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/8bcb/c1d0/510643_mini.png?m=1601433658", "bio": "", "url": "https://www.v2ex.com/u/polyang", "tagline": "", "twitter": null, "created": 1601393887, "avatar_large": "https://cdn.v2ex.com/avatar/8bcb/c1d0/510643_mini.png?m=1601433658", "avatar_mini": "https://cdn.v2ex.com/avatar/8bcb/c1d0/510643_mini.png?m=1601433658", "location": "", "btc": null, "id": 510643}, "last_reply_by": "adem13", "last_touched": 1620294370, "title": "各位买 nas 一般用来干嘛？", "url": "https://www.v2ex.com/t/775159", "created": 1620281550, "content": "看 V 站挺多人提到 nas，很好奇一般买来干嘛。\r\n\r\n还有一般在什么网站买？", "content_rendered": "看 V 站挺多人提到 nas，很好奇一般买来干嘛。<br /><br />还有一般在什么网站买？", "last_modified": 1620281550, "replies": 37, "id": 775159}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_large.png?m=1615111825", "name": "apple", "avatar_normal": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_normal.png?m=1615111825", "title": "Apple", "url": "https://www.v2ex.com/go/apple", "topics": 14763, "footer": "", "header": "设计了 <a href=\"/go/watch\">Apple Watch</a>，<a href=\"/go/ipad\">iPad</a>，<a href=\"/go/iphone\">iPhone</a>，<a href=\"/go/imac\">iMac</a> 及 <a href=\"/go/mbp\">MacBook Pro</a> 等电子产品的美国公司。", "title_alternative": "Apple", "avatar_mini": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_mini.png?m=1615111825", "stars": 1799, "aliases": [], "root": false, "id": 184, "parent_node_name": "hardware"}, "member": {"username": "FaiChou", "website": "http://faichou.com", "github": "FaiChou", "psn": "", "avatar_normal": "https://cdn.v2ex.com/gravatar/0a0b5ee72ddaab27625c5af407931a44?s=24&d=retro", "bio": "Mr. Fahrenheit", "url": "https://www.v2ex.com/u/FaiChou", "tagline": "", "twitter": "FaiChou_zh", "created": 1505371596, "avatar_large": "https://cdn.v2ex.com/gravatar/0a0b5ee72ddaab27625c5af407931a44?s=24&d=retro", "avatar_mini": "https://cdn.v2ex.com/gravatar/0a0b5ee72ddaab27625c5af407931a44?s=24&d=retro", "location": "", "btc": "", "id": 254353}, "last_reply_by": "FaiChou", "last_touched": 1620291733, "title": "AirTag 蓝牙干扰，影响汽车和手机的蓝牙通讯", "url": "https://www.v2ex.com/t/775039", "created": 1620226366, "content": "## 设备\r\n\r\n1. AirTag\r\n2. iPhone11\r\n3. Tesla Model3\r\n\r\n## 过程\r\n\r\n今天收到了 AirTag，激活后放车上，发现汽车无法通过手机的蓝牙进行音乐播放，虽然正常连接蓝牙，但音频无法传递到汽车，除了音乐，蓝牙的导航声音也无法传递到汽车。但是打电话的声音可以传递到汽车系统。\r\n\r\n## 尝试过：\r\n\r\n1. 相互断开 /忽略 /删除蓝牙设备重新连接，无效\r\n2. 使用另一部 iPhone11 连接汽车蓝牙，依然不能传递音频\r\n3. 使用汽车自带广播，可以出声，证明汽车没问题\r\n4. 重启汽车的大屏系统，无效\r\n5. 将 AirTag 拿到后备箱，好了\r\n\r\n## 结论\r\n\r\n大概率是 AirTag 的问题，可能不仅仅是对汽车的蓝牙信号干扰，但大家买 AirTag 很多人都是用来找车吧", "content_rendered": "<h2>设备</h2>\n<ol>\n<li>AirTag</li>\n<li>iPhone11</li>\n<li>Tesla Model3</li>\n</ol>\n<h2>过程</h2>\n<p>今天收到了 AirTag，激活后放车上，发现汽车无法通过手机的蓝牙进行音乐播放，虽然正常连接蓝牙，但音频无法传递到汽车，除了音乐，蓝牙的导航声音也无法传递到汽车。但是打电话的声音可以传递到汽车系统。</p>\n<h2>尝试过：</h2>\n<ol>\n<li>相互断开 /忽略 /删除蓝牙设备重新连接，无效</li>\n<li>使用另一部 iPhone11 连接汽车蓝牙，依然不能传递音频</li>\n<li>使用汽车自带广播，可以出声，证明汽车没问题</li>\n<li>重启汽车的大屏系统，无效</li>\n<li>将 AirTag 拿到后备箱，好了</li>\n</ol>\n<h2>结论</h2>\n<p>大概率是 AirTag 的问题，可能不仅仅是对汽车的蓝牙信号干扰，但大家买 AirTag 很多人都是用来找车吧</p>\n", "last_modified": 1620226366, "replies": 35, "id": 775039}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1618811339", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1618811339", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 172113, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1618811339", "stars": 3219, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"username": "zjvbqla", "website": "", "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/5cc7/759d/305333_mini.png?m=1613721293", "bio": "", "url": "https://www.v2ex.com/u/zjvbqla", "tagline": "", "twitter": null, "created": 1522647311, "avatar_large": "https://cdn.v2ex.com/avatar/5cc7/759d/305333_mini.png?m=1613721293", "avatar_mini": "https://cdn.v2ex.com/avatar/5cc7/759d/305333_mini.png?m=1613721293", "location": "", "btc": null, "id": 305333}, "last_reply_by": "james504", "last_touched": 1620292097, "title": "有很多视频要备份， macos 下天翼云盘和 onedrive 一言难尽，求备份软件介绍", "url": "https://www.v2ex.com/t/775064", "created": 1620256886, "content": "天翼云盘 macos 客户端连同步也没有，只有上传，且数据很大的时候早上起来一看，不知道怎么就没有数据传输了，按照道理黄金会员一天上限是 200g 啊？搞不懂。\r\n\r\nonedrive office365 家庭版，以前 windows 倒没有遇到什么问题，macos 下老是风火轮，不知道在干嘛？甚至一度我以为我的硬盘坏了，点击进入一些目录显示“正在载入中”，无意中关闭 onedrive 居然好了。\r\n\r\n目前一天大概是 20-30g，预计这个数量还要有所增加，所以很多方案成本太高了，用法是本地保存一点近期使用的，过几天就备份上去。\r\n\r\n记忆中好像有这样一种软件，就是去中心化的，把你的想要备份的文件打成数据碎片存储在不同的用户电脑中。除了用户本人得到的是完整的，其他任何用户得到的全是不完整的数据碎片。\r\n\r\n且无需考虑容量问题。类似的软件叫什么？", "content_rendered": "<p>天翼云盘 macos 客户端连同步也没有，只有上传，且数据很大的时候早上起来一看，不知道怎么就没有数据传输了，按照道理黄金会员一天上限是 200g 啊？搞不懂。</p>\n<p>onedrive office365 家庭版，以前 windows 倒没有遇到什么问题，macos 下老是风火轮，不知道在干嘛？甚至一度我以为我的硬盘坏了，点击进入一些目录显示“正在载入中”，无意中关闭 onedrive 居然好了。</p>\n<p>目前一天大概是 20-30g，预计这个数量还要有所增加，所以很多方案成本太高了，用法是本地保存一点近期使用的，过几天就备份上去。</p>\n<p>记忆中好像有这样一种软件，就是去中心化的，把你的想要备份的文件打成数据碎片存储在不同的用户电脑中。除了用户本人得到的是完整的，其他任何用户得到的全是不完整的数据碎片。</p>\n<p>且无需考虑容量问题。类似的软件叫什么？</p>\n", "last_modified": 1620256886, "replies": 35, "id": 775064}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1620107083", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1620107083", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 44365, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1620107083", "stars": 7361, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"username": "waruqi", "website": "https://tboox.org", "github": "waruqi", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/d4e1/9685/128521_mini.png?m=1507786719", "bio": "专注于跨平台开发解决方案：\r\n\r\n个人开源项目：https://github.com/waruqi\r\n\r\n个人主页：\r\nhttps://tboox.org\r\n\r\n项目站点：https://xmake.io\r\n\r\nQQ技术交流群: 343118190\r\n\r\n微信公众号：tboox-os", "url": "https://www.v2ex.com/u/waruqi", "tagline": "https://tboox.org", "twitter": "waruqi", "created": 1437630119, "avatar_large": "https://cdn.v2ex.com/avatar/d4e1/9685/128521_mini.png?m=1507786719", "avatar_mini": "https://cdn.v2ex.com/avatar/d4e1/9685/128521_mini.png?m=1507786719", "location": "", "btc": "", "id": 128521}, "last_reply_by": "waruqi", "last_touched": 1620289249, "title": "C/C++ 构建系统，我用 xmake", "url": "https://www.v2ex.com/t/775065", "created": 1620259117, "content": "### XMake 是什么\r\n\r\n[XMake]( https://github.com/xmake-io/xmake) 是一个基于 Lua 的 现代化 C/C++ 构建系统。\r\n\r\n它的语法简洁易上手，对新手友好，即使完全不会 lua 也能够快速入门，并且完全无任何依赖，轻量，跨平台。\r\n\r\n同时，它也是一个自满足的构建系统，拥有强大的包管理系统，快速的构建引擎。\r\n\r\n相比 Ninja/Scons/Make 作为 Build backend，CMake/Meson 作为 Project Generator，那么 XMake 就是这两者外加一个包管理。\r\n\r\n```\r\nxmake = Build backend + Project Generator + Package Manager\r\n```\r\n\r\n因此，只需要安装一个不到 3M 的 XMake 安装包，你就可以不用再安装其他各种工具，甚至连 make 都不需要安装，也不需要安装 Python 、Java 等重量级的运行时环境，就可以开始您的 C/C++ 开发之旅。\r\n\r\n也许，有人会说，编译器总需要安装的吧。这也不是必须的，因为 XMake 的包管理也支持自动远程拉取需要的各种编译工具链，比如：llvm, Mingw, Android NDK 或者交叉编译工具链。\r\n\r\n### 为什么要做 XMake\r\n\r\n每当在 Reddit 社区跟别人讨论起 XMake，大家总是会拿下面这张图来吐槽。\r\n\r\n![]( https://imgs.xkcd.com/comics/standards.png)\r\n\r\n尽管有些无奈，也被吐槽的有些麻木了，不过我还是想说明下，做 XMake 的初衷，并不是为了分裂 C/C++  生态，相反，XMake 尽可能地复用了现有生态。\r\n\r\n同时也让用户在开发 C/C++ 项目的时候，拥有与其他语言一样的良好体验，比如：Rust/Cargo，Nodejs/Npm, Dlang/Dub，不再为到处找第三包，研究如何移植编译而折腾。\r\n\r\n因此，如果您还不了解 XMake，请不要过早下定论，可以先尝试使用下，或者花点时间看完下文的详细介绍。\r\n\r\n### XMake 的特性和优势\r\n\r\n经常有人问我 XMake 有什么特别之处，相比现有 CMake 、Meson 此类构建工具有什么优势，我为什么要使用 XMake 而不是 CMake ？\r\n\r\n先说特点和优势，XMake 有以下几点：\r\n\r\n- 简洁易学的配置语法，非 DSL\r\n- 强大的包管理，支持语义版本，工具链管理\r\n- 足够轻量，无依赖\r\n- 极速编译，构建速度和 Ninja 一样快\r\n- 简单方便的多平台、工具链切换\r\n- 完善的插件系统\r\n- 灵活的构建规则\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n至于 CMake，毕竟已成事实上的标准，生态完善，功能强大。\r\n\r\n我从没想过让 XMake 去替代它，也替代不了，完全不是一个量级的，但是 CMake 也有许多为人所诟病的短板，比如：语法复杂难懂，包管理支持不完善等等。\r\n\r\n因此使用 XMake 可以作为一种补充，对于那些想要简单快速入门 C/C++ 开发的新手，或者想要更加方便易用的包管理，或者想临时快速写一些短小的测试项目。\r\n\r\nXMake 都可以帮他们提升开发效率，让其更加关注 C/C++ 项目本身，而不是花更多的时间在构建工具和开发环境上。\r\n\r\n下面，我来具体介绍 XMake 的这些主要特性。\r\n\r\n### 语法简洁易上手\r\n\r\nCMake 自己设计一门 DSL 语言用来做项目配置，这对用户来讲提高了学习成本，而且它的语法可读性不是很直观，很容易写出过于复杂的配置脚本，也提高了维护成本。\r\n\r\n而 XMake 复用现有知名的 Lua 语言作为基础，并且其上提供了更加简单直接的配置语法。\r\n\r\nLua 本身就是一门简单轻量的胶水语言，关键字和内置类型就那么几种，看个一篇文章，就能基本入门了，并且相比 DSL，能够从网上更方便的获取到大量相关资料和教程。\r\n\r\n#### 基础语法\r\n\r\n不过，还是有人会吐槽：那不是还得学习 Lua 么？\r\n\r\n其实也不用，XMake 采用了 `描述域` 和 `脚本域` 分离的方式，使得初学者用户在 80% 的情况下，只需要在描述域以更简单直接的方式来配置，完全可以不把它当成 Lua 脚本，例如：\r\n\r\n```lua\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_files(\"test/*.c\", \"example/**.cpp\")\r\n```\r\n\r\n如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好，不过我个人还是建议使用上面的方式）\r\n\r\n```lua\r\ntarget \"test\"\r\n    set_kind \"binary\"\r\n    add_files \"src/*.c\"\r\n    add_files \"test/*.c\"\r\n    add_files \"example/**.cpp\"\r\n```\r\n\r\n我们只需要知道常用配置接口，即使不完全不会 Lua 也能快速配置了。\r\n\r\n我们可以对比下 CMake 的配置：\r\n\r\n```cmake\r\nadd_executable(test \"\")\r\nfile(GLOB SRC_FILES \"src/*.c\")\r\nfile(GLOB TEST_FILES \"test/*.c\")\r\nfile(GLOB_RECURSE EXAMPLE_FILES \"example/*.cpp\")\r\ntarget_sources(test PRIVATE\r\n    ${SRC_FILES}\r\n    ${TEST_FILES}\r\n    ${EXAMPLE_FILES}\r\n)\r\n```\r\n\r\n哪个更直观可读，一目了然。\r\n\r\n#### 条件配置\r\n\r\n如果，你已经初步了解了一些 Lua 等基础知识，比如 `if then` 等条件判断，那么可以进一步做一些条件配置。\r\n\r\n```lua\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/main.c\")\r\n    if is_plat(\"macosx\", \"linux\") then\r\n        add_defines(\"TEST1\", \"TEST2\")\r\n    end\r\n    if is_plat(\"windows\") and is_mode(\"release\") then\r\n        add_cxflags(\"-Ox\", \"-fp:fast\")\r\n    end\r\n```\r\n\r\n继续对比下 CMake 版本配置：\r\n\r\n```cmake\r\nadd_executable(test \"\")\r\nif (APPLE OR LINUX)\r\n    target_compile_definitions(test PRIVATE TEST1 TEST2)\r\nendif()\r\nif (WIN32)\r\n    target_compile_options(test PRIVATE $<$<CONFIG:Release>:-Ox -fp:fast>)\r\nendif()\r\ntarget_sources(test PRIVATE\r\n    src/main.c\r\n)\r\n```\r\n\r\n#### 复杂脚本\r\n\r\n如果你已经晋升为 XMake 的高端玩家，Lua 语法了然于胸，想要更加灵活的定制化配置需要，并且描述域的几行简单配置已经满足不了你的需求。\r\n\r\n那么 XMake 也提供了更加完整的 Lua 脚本定制化能力，你可以写任何复杂的脚本。\r\n\r\n比如在构建之前，对所有源文件进行一些预处理，在构建之后，执行外部 gradle 命令进行后期打包，甚至我们还可以重写内部链接规则，实现深度定制编译，我们可以通过[import]( https://xmake.io/#/zh/manual?id=import) 接口，导入内置的 linker 扩展模块，实现复杂灵活的链接过程。\r\n\r\n```lua\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    before_build_file(function (target, sourcefile)\r\n        io.replace(sourcefile, \"#define HAVE_XXX 1\", \"#define HAVE_XXX 0\")\r\n    end)\r\n    on_link(function (target)\r\n        import(\"core.tool.linker\")\r\n        linker.link(\"binary\", \"cc\", target:objectfiles(), target:targetfile(), {target = target})\r\n    end)\r\n    after_build(function (target)\r\n        if is_plat(\"android\" then\r\n            os.cd(\"android/app\")\r\n            os.exec(\"./gradlew app:assembleDebug\")\r\n        end\r\n    end)\r\n```\r\n\r\n如果换成 CMake，也可以 add_custom_command 里面实现，不过里面似乎只能简单的执行一些批处理命令，没法做各种复杂的逻辑判断，模块加载，自定义配置脚本等等。\r\n\r\n当然，使用 cmake 肯定也能实现上面描述的功能，但绝对不会那么简单。\r\n\r\n如果有熟悉 cmake 的人，也可以尝试帮忙完成下面的配置：\r\n\r\n```cmake\r\nadd_executable(test \"\")\r\nfile(GLOB SRC_FILES \"src/*.c\")\r\nadd_custom_command(TARGET test PRE_BUILD\r\n    -- TODO\r\n    COMMAND echo hello\r\n)\r\nadd_custom_command(TARGET test POST_BUILD\r\n    COMMAND cd android/app\r\n    COMMAND ./gradlew app:assembleDebug\r\n)\r\n-- How can we override link stage?\r\ntarget_sources(test PRIVATE\r\n    ${SRC_FILES}\r\n)\r\n```\r\n\r\n### 强大的包管理\r\n\r\n众所周知，做 C/C++ 相关项目开发，最头大的就是各种依赖包的集成，由于没有像 Rust/Cargo 那样完善的包管理系统。\r\n\r\n因此，我们每次想使用一个第三方库，都需要各种找，研究各种平台的移植编译，还经常遇到各种编译问题，极大耽误了开发者时间，无法集中精力去投入到实际的项目开发中去。\r\n\r\n好不容易当前平台搞定了，换到其他平台，有需要重新折腾一遍依赖包，为了解决这个问题，出现了一些第三方的包管理器，比如 vcpkg/conan/conda 等等，但有些不支持语义版本，有些支持的平台有限，但不管怎样，总算是为解决 C/C++ 库的依赖管理迈进了很大一步。\r\n\r\n但是，光有包管理器，C/C++ 项目中使用它们还是比较麻烦，因为还需要对应构建工具能够很好的对其进行集成支持才行。\r\n\r\n#### CMake 和 Vcpkg\r\n\r\n我们先来看下 CMake 和 Vcpkg 的集成支持：\r\n\r\n```\r\ncmake_minimum_required(VERSION 3.0)\r\nproject(test)\r\nfind_package(unofficial-sqlite3 CONFIG REQUIRED)\r\nadd_executable(main main.cpp)\r\ntarget_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\r\n```\r\n\r\n缺点：\r\n\r\n- 还需要额外配置 `-DCMAKE_TOOLCHAIN_FILE=<vcpkg_dir>/scripts/buildsystems/vcpkg.cmake\"`\r\n- 不支持自动安装依赖包，还需要用户手动执行 `vcpkg install xxx` 命令安装\r\n- vcpkg 的语义版本选择不支持 （据说新版本开始支持了）\r\n\r\n#### CMake 和 Conan\r\n\r\n```\r\n```cmake\r\ncmake_minimum_required(VERSION 2.8.12)\r\nproject(Hello)\r\n\r\nadd_definitions(\"-std=c++11\")\r\n\r\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\r\nconan_basic_setup()\r\n\r\nadd_executable(hello hello.cpp)\r\ntarget_link_libraries(hello gtest)\r\n```\r\n\r\nconanfile.txt\r\n\r\n```text\r\n[requires]\r\ngtest/1.10.0\r\n\r\n[generators]\r\ncmake\r\n```\r\n\r\n缺点：\r\n\r\n- 同样，还是需要额外调用 `conan install ..` 来安装包\r\n- 还需要额外配置一个 conanfile.txt 文件去描述包依赖规则\r\n\r\n#### Meson 和 Vcpkg\r\n\r\n我没找到如何在 Meson 中去使用 vcpkg 包，仅仅找到一篇相关的 [Issue #3500]( https://github.com/mesonbuild/meson/issues/3500) 讨论。\r\n\r\n#### Meson 和 Conan\r\n\r\nMeson 似乎还没有对 Conan 进行支持，但是 Conan 官方文档上有解决方案，对齐进行支持，但是很复杂，我是没看会，大家可以自行研究：[https://docs.conan.io/en/latest/reference/build_helpers/meson.html]( https://docs.conan.io/en/latest/reference/build_helpers/meson.html)\r\n\r\n#### XMake 和 Vcpkg\r\n\r\n前面讲了这么多，其他构建工具和包管理的集成，个人感觉用起来很麻烦，而且不同的包管理器，集成方式差别很大，用户想要快速从 Vcpkg 切换到 Conan 包，改动量非常大。\r\n\r\n接下来，我们来看看 XMake 中集成使用 Vcpkg 提供的包：\r\n\r\n```lua\r\nadd_requires(\"vcpkg::zlib\", {alias = \"zlib\"})\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_packages(\"zlib\")\r\n```\r\n\r\n我们只需要通过 `add_requires` 配置上对应的包名，以及 `vcpkg::` 包命名空间，就能直接集成使用 vcpkg 提供的 zlib 包。\r\n\r\n然后，我们只需要执行 xmake 命令，既可完成整个编译过程，包括 zlib 包的自动安装，无需额外手动执行 `vcpkg install zlib`。\r\n\r\n```bash\r\n$ xmake\r\nnote: try installing these packages (pass -y to skip confirm)?\r\n-> vcpkg::zlib\r\nplease input: y (y/n)\r\n\r\n=> install vcpkg::zlib .. ok\r\n[ 25%]: compiling.release src\\main.cpp\r\n[ 50%]: linking.release test\r\n[100%]: build ok!\r\n```\r\n\r\n#### XMake 和 Conan\r\n\r\n接下来是集成 Conan 的包，完全一样的方式，仅仅执行换个包管理器名字。\r\n\r\n```lua\r\nadd_requires(\"conan::zlib\", {alias = \"zlib\"})\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_packages(\"zlib\")\r\n```\r\n\r\nXMake 同样会自动安装 conan 中的 zlib 包，然后自动集成编译。\r\n\r\n#### XMake 自建包管理\r\n\r\nXMake 跟 CMake 还有其他构建系统，最大的不同点，也就是最大的优势之一，就是它有完全自建的包管理系统，我们完全可以不依赖 vcpkg/conan，也可以快速集成依赖包，比如：\r\n\r\n```lua\r\nadd_requires(\"zlib 1.2.x\", \"tbox >= 1.6.0\")\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_packages(\"zlib\", \"tbox\")\r\n```\r\n\r\n而且，它还支持完整的语义版本选择，多平台的包集成，交叉编译工具链的包集成，甚至编译工具链包的自动拉取使用。\r\n\r\n不仅如此，我们开可以对定制化配置对自建包的依赖，例如：\r\n\r\n##### 使用调式版本依赖包\r\n\r\n我们可以使用 debug 版本库，实现对依赖库的断点调试。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {debug = true})\r\n```\r\n\r\n##### 设置 msvc 运行时库\r\n\r\n```lua\r\nadd_requires(\"zlib\", {configs = {vs_runtime = \"MD\"}})\r\n```\r\n\r\n##### 使用动态库\r\n\r\n默认集成的是静态库，我们也可以切换到动态库。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {configs = {shared = true}})\r\n```\r\n\r\n##### 语义版本支持\r\n\r\nXMake 的自建包集成支持完整的版本语义规范。\r\n\r\n```lua\r\nadd_requires(\"zlib 1.2.x\")\r\nadd_requires(\"zlib >=1.2.10\")\r\nadd_requires(\"zlib ~1.2.0\")\r\n```\r\n\r\n##### 禁止使用系统库\r\n\r\n默认情况下，如果版本匹配，XMake 会优先查找使用系统上用户已经安装的库，当然我们也可以强制禁止查找使用系统库，仅仅从自建包仓库中下载安装包。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {system = true})\r\n```\r\n\r\n##### 可选依赖包\r\n\r\n如果依赖包集成失败，XMake 会自动报错，中断编译，提示用户：`zlib not found`，但是我们也可以设置为可选包集成，这样的话，即使库最终没安装成功，也不影响项目的编译，仅仅只是跳过这个依赖。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {optional = true})\r\n```\r\n\r\n##### 包的定制化配置\r\n\r\n比如，集成使用开启了 context/coroutine 模块配置的 boost 库。\r\n\r\n```lua\r\nadd_requires(\"boost\", {configs = {context = true, coroutine = true}})\r\n```\r\n\r\n#### 支持的包管理仓库\r\n\r\nXMake 除了支持 vcpkg/conan 还有自建仓库的包集成支持，还支持其他的包管理仓库，例如：Conda/Homebrew/Apt/Pacman/Clib/Dub 等等，而且集成方式完全一致。\r\n\r\n用户可与快速切换使用其他的仓库包，而不需要花太多时间去研究如何集成它们。\r\n\r\n因此，XMake 并没有破坏 C/C++ 生态，而是极大的复用现有 C/C++ 生态的基础上，努力改进用户对 C/C++ 依赖包的使用体验，提高开发效率，让用户能够拥有更多的时间去关注项目本身。\r\n\r\n* 官方自建仓库 [xmake-repo]( https://github.com/xmake-io/xmake-repo) (tbox >1.6.1)\r\n* 官方包管理器 [Xrepo]( https://github.com/xmake-io/xrepo)\r\n* [用户自建仓库]( https://xmake.io/#/zh-cn/package/remote_package?id=%e4%bd%bf%e7%94%a8%e8%87%aa%e5%bb%ba%e7%a7%81%e6%9c%89%e5%8c%85%e4%bb%93%e5%ba%93)\r\n* Conan (conan::openssl/1.1.1g)\r\n* Conda (conda::libpng 1.3.67)\r\n* Vcpkg (vcpkg:ffmpeg)\r\n* Homebrew/Linuxbrew (brew::pcre2/libpcre2-8)\r\n* Pacman on archlinux/msys2 (pacman::libcurl)\r\n* Apt on ubuntu/debian (apt::zlib1g-dev)\r\n* Clib (clib::clibs/bytes@0.0.4)\r\n* Dub (dub::log 0.4.3)\r\n\r\n#### 独立的包管理命令（ Xrepo ）\r\n\r\n为了方便 XMake 的自建仓库中的包管理，以及第三方包的管理使用，我们也提供了独立的 Xrepo cli 命令工具，来方便的管理我们的依赖包\r\n\r\n我们可以使用这个工具，快速方便的完成下面的管理操作：\r\n\r\n- 安装包：`xrepo install zlib`\r\n- 卸载包：`xrepo remove zlib`\r\n- 获取包信息：`xrepo info zlib`\r\n- 获取包编译链接 flags：`xrepo fetch zlib`\r\n- 加载包虚拟 Shell 环境：`xrepo env shell` （这是一个很强大的特性）\r\n\r\n我们可以到 [Xrepo 项目主页]( https://github.com/xmake-io/xrepo) 查看更多的介绍和使用方式。\r\n\r\n![]( https://xrepo.xmake.io/assets/img/xrepo.gif)\r\n\r\n\r\n### 轻量无依赖\r\n\r\n使用 Meson/Scons 需要先安装 python/pip，使用 Bazel 需要先安装 java 等运行时环境，而 XMake 不需要额外安装任何依赖库和环境，自身安装包仅仅 2-3M，非常的轻量。\r\n\r\n尽管 XMake 是基于 lua，但是借助于 lua 胶水语言的轻量级特性，xmake 已将其完全内置，因此安装完 XMake 等同于拥有了一个完整的 lua vm 。\r\n\r\n有人会说，编译工具链总还是需要的吧，也不完全是，Windows 上，我们提供了预编译安装包，可以直接下载安装编译，地址见：[Releases]( https://github.com/xmake-io/xmake/releases)\r\n\r\n另外，XMake 还支持远程拉取编译工具链，因此即使你的系统环境，还没有安装任何编译器，也没关系，用户完全不用考虑如何折腾编译环境，只需要在 xmake.lua 里面配置上需要的工具链即可。\r\n\r\n比如，我们在 Windows 上使用 mingw-w64 工具链来编译 C/C++ 工程，只需要做如下配置即可。\r\n\r\n```lua\r\nadd_requires(\"mingw-w64\")\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    set_toolchains(\"mingw@mingw-w64\")\r\n```\r\n\r\n通过 `set_toolchains` 配置绑定 mingw-w64 工具链包后，XMake 就会自动检测当前系统是否存在 mingw-64，如果还没安装，它会自动下载安装，然后完成项目编译，整个过程，用户仅仅只需要执行 `xmake` 这个命令就能完成。\r\n\r\n```bash\r\n$ xmake\r\nnote: try installing these packages (pass -y to skip confirm)?\r\nin xmake-repo:\r\n-> mingw-w64 8.1.0 [vs_runtime:MT]\r\nplease input: y (y/n)\r\n\r\n=> download https://jaist.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z .. ok\r\nchecking for mingw directory ... C:\\Users\\ruki\\AppData\\Local\\.xmake\\packages\\m\\mingw-w64\\8.1.0\\aad6257977e0449595004d7441358fc5\r\n[ 25%]: compiling.release src\\main.cpp\r\n[ 50%]: linking.release test.exe\r\n[100%]: build ok!\r\n```\r\n\r\n除了 mingw-w64，我们还可以配置远程拉取使用其他的工具链，甚至交叉编译工具链，例如：llvm-mingw, llvm, tinycc, muslcc, gnu-rm, zig 等等。\r\n\r\n如果大家还想进一步了解远程工具链的拉取集成，可以看下文档：[自动拉取远程工具链]( https://xmake.io/#/zh-cn/package/remote_package?id=%e8%87%aa%e5%8a%a8%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%b7%a5%e5%85%b7%e9%93%be)。\r\n\r\n### 极速并行编译\r\n\r\n大家都知道 Ninja 构建非常快，因此很多人都喜欢用 CMake/Meson 生成 build.ninja  后，使用 Ninja 来满足极速构建的需求。\r\n\r\n尽管 Ninja 很快，但是我们还是需要先通过 meson.build 和 CMakelist.txt 文件生成 build.ninja 才行，这个生成过程也会占用几秒甚至十几秒的时间。\r\n\r\n而 XMake 不仅仅拥有和 Ninja 近乎相同的构建速度，而且不需要额外再生成其他构建文件，直接内置构建系统，任何情况下，只需要一个 `xmake` 命令就可以实现极速编译。\r\n\r\n我们也做过一些对比测试数据，供大家参考：\r\n\r\n#### 多任务并行编译测试\r\n\r\n| 构建系统        | Termux (8core/-j12) | 构建系统         | MacOS (8core/-j12) |\r\n|-----            | ----                | ---              | ---                |\r\n|xmake            | 24.890s             | xmake            | 12.264s            |\r\n|ninja            | 25.682s             | ninja            | 11.327s            |\r\n|cmake(gen+make)  | 5.416s+28.473s      | cmake(gen+make)  | 1.203s+14.030s     |\r\n|cmake(gen+ninja) | 4.458s+24.842s      | cmake(gen+ninja) | 0.988s+11.644s     |\r\n\r\n#### 单任务编译测试\r\n\r\n| 构建系统        | Termux (-j1)     | 构建系统         | MacOS (-j1)    |\r\n|-----            | ----             | ---              | ---            |\r\n|xmake            | 1m57.707s        | xmake            | 39.937s        |\r\n|ninja            | 1m52.845s        | ninja            | 38.995s        |\r\n|cmake(gen+make)  | 5.416s+2m10.539s | cmake(gen+make)  | 1.203s+41.737s |\r\n|cmake(gen+ninja) | 4.458s+1m54.868s | cmake(gen+ninja) | 0.988s+38.022s |\r\n\r\n\r\n### 傻瓜式多平台编译\r\n\r\nXMake 的另外一个特点，就是高效简单的多平台编译，不管你是编译 windows/linux/macOS 下的程序，还是编译 iphoneos/android 又或者是交叉编译。\r\n\r\n编译的配置方式大同小异，不必让用户去这折腾研究各个平台下如何去编译。\r\n\r\n![]( https://xmake.io/assets/img/index/xmake-basic-render.gif)\r\n\r\n#### 编译本机 Windows/Linux/MacOS  程序\r\n\r\n当前本机程序编译，我们仅仅只需要执行：\r\n\r\n```bash\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake --build ..\r\n```\r\n\r\n#### 编译 Android 程序\r\n\r\n```bash\r\n$ xmake f -p android --ndk=~/android-ndk-r21e\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake -DCMAKE_TOOLCHAIN_FILE=~/android-ndk-r21e/build/cmake/android.toolchain.cmake ..\r\n$ make\r\n```\r\n\r\n#### 编译 iOS 程序\r\n\r\n```bash\r\n$ xmake f -p iphoneos\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ wget https://raw.githubusercontent.com/leetal/ios-cmake/master/ios.toolchain.cmake\r\n$ cmake -DCMAKE_TOOLCHAIN_FILE=`pwd`/ios.toolchain.cmake ..\r\n$ make\r\n```\r\n\r\n我没有找到很方便的方式去配置编译 ios 程序，仅仅只能从其他地方找到一个第三方的 ios 工具链去配置编译。\r\n\r\n#### 交叉编译\r\n\r\n我们通常只需要设置交叉编译工具链根目录，XMake 会自动检测工具链结构，提取里面的编译器参与编译，不需要额外配置什么。\r\n\r\n```bash\r\n$ xmake f -p cross --sdk=~/aarch64-linux-musl-cross\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n我们需要先额外写一个 cross-toolchain.cmake 的交叉工具链配置文件。\r\n\r\n```cmake\r\nset(CMAKE_SYSTEM_NAME Linux)\r\nset(CMAKE_SYSTEM_PROCESSOR aarch64)\r\n\r\nset(TOOL_CHAIN_DIR ~/aarch64-linux-musl)\r\nset(TOOL_CHAIN_INCLUDE ${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\r\nset(TOOL_CHAIN_LIB ${TOOL_CHAIN_DIR}/aarch64-linux-musl/lib)\r\n\r\nset(CMAKE_C_COMPILER \"aarch64-linux-gcc\")\r\nset(CMAKE_CXX_COMPILER \"aarch64-linux-g++\")\r\n\r\nset(CMAKE_FIND_ROOT_PATH ${TOOL_CHAIN_DIR}/aarch64-linux-musl)\r\n\r\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\r\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\r\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\r\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\r\n\r\ninclude_directories(${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\r\nset(CMAKE_INCLUDE_PATH ${TOOL_CHAIN_INCLUDE})\r\nset(CMAKE_LIBRARY_PATH ${TOOL_CHAIN_LIB})\r\n```\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake -DCMAKE_TOOLCHAIN_FILE=../cross-toolchain.cmake ..\r\n$ make\r\n```\r\n\r\n### 结语\r\n\r\n如果你是 C/C++ 开发的新手，可以通过 XMake 快速上手入门 C/C++ 编译构建。\r\n\r\n如果你想开发维护跨平台 C/C++ 项目，也可以考虑使用 XMake 来维护构建，提高开发效率，让你更加专注于项目本身，不再为折腾移植依赖库而烦恼。\r\n\r\n欢迎关注 XMake 项目：\r\n\r\n- [Github 项目地址]( https://github.com/xmake-io/xmake/)\r\n- [项目主页]( https://xmake.io/#/)\r\n- [XMake 包管理仓库]( https://github.com/xmake-io/xmake-repo)\r\n- 社区\r\n  - [Telegram 群组]( https://t.me/tbooxorg)\r\n  - [Discord 聊天室]( https://discord.gg/xmake)\r\n  - QQ 群：343118190, 662147501\r\n  - 微信公众号：tboox-os\r\n - 课程：[Xmake 带你轻松构建 C/C++ 项目]( https://xmake.io/#/zh-cn/about/course)\r\n - 活动：[开源之夏 & Xmake]( https://tboox.org/cn/2021/04/29/xmake-summer-ospp/)", "content_rendered": "<h3>XMake 是什么</h3>\n<p><a href=\"https://github.com/xmake-io/xmake\" rel=\"nofollow\">XMake</a> 是一个基于 Lua 的 现代化 C/C++ 构建系统。</p>\n<p>它的语法简洁易上手，对新手友好，即使完全不会 lua 也能够快速入门，并且完全无任何依赖，轻量，跨平台。</p>\n<p>同时，它也是一个自满足的构建系统，拥有强大的包管理系统，快速的构建引擎。</p>\n<p>相比 Ninja/Scons/Make 作为 Build backend，CMake/Meson 作为 Project Generator，那么 XMake 就是这两者外加一个包管理。</p>\n<pre><code>xmake = Build backend + Project Generator + Package Manager\n</code></pre>\n<p>因此，只需要安装一个不到 3M 的 XMake 安装包，你就可以不用再安装其他各种工具，甚至连 make 都不需要安装，也不需要安装 Python 、Java 等重量级的运行时环境，就可以开始您的 C/C++ 开发之旅。</p>\n<p>也许，有人会说，编译器总需要安装的吧。这也不是必须的，因为 XMake 的包管理也支持自动远程拉取需要的各种编译工具链，比如：llvm, Mingw, Android NDK 或者交叉编译工具链。</p>\n<h3>为什么要做 XMake</h3>\n<p>每当在 Reddit 社区跟别人讨论起 XMake，大家总是会拿下面这张图来吐槽。</p>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://imgs.xkcd.com/comics/standards.png\"/></p>\n<p>尽管有些无奈，也被吐槽的有些麻木了，不过我还是想说明下，做 XMake 的初衷，并不是为了分裂 C/C++  生态，相反，XMake 尽可能地复用了现有生态。</p>\n<p>同时也让用户在开发 C/C++ 项目的时候，拥有与其他语言一样的良好体验，比如：Rust/Cargo，Nodejs/Npm, Dlang/Dub，不再为到处找第三包，研究如何移植编译而折腾。</p>\n<p>因此，如果您还不了解 XMake，请不要过早下定论，可以先尝试使用下，或者花点时间看完下文的详细介绍。</p>\n<h3>XMake 的特性和优势</h3>\n<p>经常有人问我 XMake 有什么特别之处，相比现有 CMake 、Meson 此类构建工具有什么优势，我为什么要使用 XMake 而不是 CMake ？</p>\n<p>先说特点和优势，XMake 有以下几点：</p>\n<ul>\n<li>简洁易学的配置语法，非 DSL</li>\n<li>强大的包管理，支持语义版本，工具链管理</li>\n<li>足够轻量，无依赖</li>\n<li>极速编译，构建速度和 Ninja 一样快</li>\n<li>简单方便的多平台、工具链切换</li>\n<li>完善的插件系统</li>\n<li>灵活的构建规则</li>\n</ul>\n<p>至于 CMake，毕竟已成事实上的标准，生态完善，功能强大。</p>\n<p>我从没想过让 XMake 去替代它，也替代不了，完全不是一个量级的，但是 CMake 也有许多为人所诟病的短板，比如：语法复杂难懂，包管理支持不完善等等。</p>\n<p>因此使用 XMake 可以作为一种补充，对于那些想要简单快速入门 C/C++ 开发的新手，或者想要更加方便易用的包管理，或者想临时快速写一些短小的测试项目。</p>\n<p>XMake 都可以帮他们提升开发效率，让其更加关注 C/C++ 项目本身，而不是花更多的时间在构建工具和开发环境上。</p>\n<p>下面，我来具体介绍 XMake 的这些主要特性。</p>\n<h3>语法简洁易上手</h3>\n<p>CMake 自己设计一门 DSL 语言用来做项目配置，这对用户来讲提高了学习成本，而且它的语法可读性不是很直观，很容易写出过于复杂的配置脚本，也提高了维护成本。</p>\n<p>而 XMake 复用现有知名的 Lua 语言作为基础，并且其上提供了更加简单直接的配置语法。</p>\n<p>Lua 本身就是一门简单轻量的胶水语言，关键字和内置类型就那么几种，看个一篇文章，就能基本入门了，并且相比 DSL，能够从网上更方便的获取到大量相关资料和教程。</p>\n<h4>基础语法</h4>\n<p>不过，还是有人会吐槽：那不是还得学习 Lua 么？</p>\n<p>其实也不用，XMake 采用了 <code>描述域</code> 和 <code>脚本域</code> 分离的方式，使得初学者用户在 80% 的情况下，只需要在描述域以更简单直接的方式来配置，完全可以不把它当成 Lua 脚本，例如：</p>\n<pre><code class=\"language-lua\">target(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_files(\"test/*.c\", \"example/**.cpp\")\n</code></pre>\n<p>如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好，不过我个人还是建议使用上面的方式）</p>\n<pre><code class=\"language-lua\">target \"test\"\n    set_kind \"binary\"\n    add_files \"src/*.c\"\n    add_files \"test/*.c\"\n    add_files \"example/**.cpp\"\n</code></pre>\n<p>我们只需要知道常用配置接口，即使不完全不会 Lua 也能快速配置了。</p>\n<p>我们可以对比下 CMake 的配置：</p>\n<pre><code class=\"language-cmake\">add_executable(test \"\")\nfile(GLOB SRC_FILES \"src/*.c\")\nfile(GLOB TEST_FILES \"test/*.c\")\nfile(GLOB_RECURSE EXAMPLE_FILES \"example/*.cpp\")\ntarget_sources(test PRIVATE\n    ${SRC_FILES}\n    ${TEST_FILES}\n    ${EXAMPLE_FILES}\n)\n</code></pre>\n<p>哪个更直观可读，一目了然。</p>\n<h4>条件配置</h4>\n<p>如果，你已经初步了解了一些 Lua 等基础知识，比如 <code>if then</code> 等条件判断，那么可以进一步做一些条件配置。</p>\n<pre><code class=\"language-lua\">target(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/main.c\")\n    if is_plat(\"macosx\", \"linux\") then\n        add_defines(\"TEST1\", \"TEST2\")\n    end\n    if is_plat(\"windows\") and is_mode(\"release\") then\n        add_cxflags(\"-Ox\", \"-fp:fast\")\n    end\n</code></pre>\n<p>继续对比下 CMake 版本配置：</p>\n<pre><code class=\"language-cmake\">add_executable(test \"\")\nif (APPLE OR LINUX)\n    target_compile_definitions(test PRIVATE TEST1 TEST2)\nendif()\nif (WIN32)\n    target_compile_options(test PRIVATE $&lt;$&lt;CONFIG:Release&gt;:-Ox -fp:fast&gt;)\nendif()\ntarget_sources(test PRIVATE\n    src/main.c\n)\n</code></pre>\n<h4>复杂脚本</h4>\n<p>如果你已经晋升为 XMake 的高端玩家，Lua 语法了然于胸，想要更加灵活的定制化配置需要，并且描述域的几行简单配置已经满足不了你的需求。</p>\n<p>那么 XMake 也提供了更加完整的 Lua 脚本定制化能力，你可以写任何复杂的脚本。</p>\n<p>比如在构建之前，对所有源文件进行一些预处理，在构建之后，执行外部 gradle 命令进行后期打包，甚至我们还可以重写内部链接规则，实现深度定制编译，我们可以通过<a href=\"https://xmake.io/#/zh/manual?id=import\" rel=\"nofollow\">import</a> 接口，导入内置的 linker 扩展模块，实现复杂灵活的链接过程。</p>\n<pre><code class=\"language-lua\">target(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    before_build_file(function (target, sourcefile)\n        io.replace(sourcefile, \"#define HAVE_XXX 1\", \"#define HAVE_XXX 0\")\n    end)\n    on_link(function (target)\n        import(\"core.tool.linker\")\n        linker.link(\"binary\", \"cc\", target:objectfiles(), target:targetfile(), {target = target})\n    end)\n    after_build(function (target)\n        if is_plat(\"android\" then\n            os.cd(\"android/app\")\n            os.exec(\"./gradlew app:assembleDebug\")\n        end\n    end)\n</code></pre>\n<p>如果换成 CMake，也可以 add_custom_command 里面实现，不过里面似乎只能简单的执行一些批处理命令，没法做各种复杂的逻辑判断，模块加载，自定义配置脚本等等。</p>\n<p>当然，使用 cmake 肯定也能实现上面描述的功能，但绝对不会那么简单。</p>\n<p>如果有熟悉 cmake 的人，也可以尝试帮忙完成下面的配置：</p>\n<pre><code class=\"language-cmake\">add_executable(test \"\")\nfile(GLOB SRC_FILES \"src/*.c\")\nadd_custom_command(TARGET test PRE_BUILD\n    -- TODO\n    COMMAND echo hello\n)\nadd_custom_command(TARGET test POST_BUILD\n    COMMAND cd android/app\n    COMMAND ./gradlew app:assembleDebug\n)\n-- How can we override link stage?\ntarget_sources(test PRIVATE\n    ${SRC_FILES}\n)\n</code></pre>\n<h3>强大的包管理</h3>\n<p>众所周知，做 C/C++ 相关项目开发，最头大的就是各种依赖包的集成，由于没有像 Rust/Cargo 那样完善的包管理系统。</p>\n<p>因此，我们每次想使用一个第三方库，都需要各种找，研究各种平台的移植编译，还经常遇到各种编译问题，极大耽误了开发者时间，无法集中精力去投入到实际的项目开发中去。</p>\n<p>好不容易当前平台搞定了，换到其他平台，有需要重新折腾一遍依赖包，为了解决这个问题，出现了一些第三方的包管理器，比如 vcpkg/conan/conda 等等，但有些不支持语义版本，有些支持的平台有限，但不管怎样，总算是为解决 C/C++ 库的依赖管理迈进了很大一步。</p>\n<p>但是，光有包管理器，C/C++ 项目中使用它们还是比较麻烦，因为还需要对应构建工具能够很好的对其进行集成支持才行。</p>\n<h4>CMake 和 Vcpkg</h4>\n<p>我们先来看下 CMake 和 Vcpkg 的集成支持：</p>\n<pre><code>cmake_minimum_required(VERSION 3.0)\nproject(test)\nfind_package(unofficial-sqlite3 CONFIG REQUIRED)\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\n</code></pre>\n<p>缺点：</p>\n<ul>\n<li>还需要额外配置 <code>-DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg_dir&gt;/scripts/buildsystems/vcpkg.cmake\"</code></li>\n<li>不支持自动安装依赖包，还需要用户手动执行 <code>vcpkg install xxx</code> 命令安装</li>\n<li>vcpkg 的语义版本选择不支持 （据说新版本开始支持了）</li>\n</ul>\n<h4>CMake 和 Conan</h4>\n<pre><code>```cmake\ncmake_minimum_required(VERSION 2.8.12)\nproject(Hello)\n\nadd_definitions(\"-std=c++11\")\n\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\nconan_basic_setup()\n\nadd_executable(hello hello.cpp)\ntarget_link_libraries(hello gtest)\n</code></pre>\n<p>conanfile.txt</p>\n<pre><code class=\"language-text\">[requires]\ngtest/1.10.0\n\n[generators]\ncmake\n</code></pre>\n<p>缺点：</p>\n<ul>\n<li>同样，还是需要额外调用 <code>conan install ..</code> 来安装包</li>\n<li>还需要额外配置一个 conanfile.txt 文件去描述包依赖规则</li>\n</ul>\n<h4>Meson 和 Vcpkg</h4>\n<p>我没找到如何在 Meson 中去使用 vcpkg 包，仅仅找到一篇相关的 <a href=\"https://github.com/mesonbuild/meson/issues/3500\" rel=\"nofollow\">Issue #3500</a> 讨论。</p>\n<h4>Meson 和 Conan</h4>\n<p>Meson 似乎还没有对 Conan 进行支持，但是 Conan 官方文档上有解决方案，对齐进行支持，但是很复杂，我是没看会，大家可以自行研究：<a href=\"https://docs.conan.io/en/latest/reference/build_helpers/meson.html\" rel=\"nofollow\">https://docs.conan.io/en/latest/reference/build_helpers/meson.html</a></p>\n<h4>XMake 和 Vcpkg</h4>\n<p>前面讲了这么多，其他构建工具和包管理的集成，个人感觉用起来很麻烦，而且不同的包管理器，集成方式差别很大，用户想要快速从 Vcpkg 切换到 Conan 包，改动量非常大。</p>\n<p>接下来，我们来看看 XMake 中集成使用 Vcpkg 提供的包：</p>\n<pre><code class=\"language-lua\">add_requires(\"vcpkg::zlib\", {alias = \"zlib\"})\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_packages(\"zlib\")\n</code></pre>\n<p>我们只需要通过 <code>add_requires</code> 配置上对应的包名，以及 <code>vcpkg::</code> 包命名空间，就能直接集成使用 vcpkg 提供的 zlib 包。</p>\n<p>然后，我们只需要执行 xmake 命令，既可完成整个编译过程，包括 zlib 包的自动安装，无需额外手动执行 <code>vcpkg install zlib</code>。</p>\n<pre><code class=\"language-bash\">$ xmake\nnote: try installing these packages (pass -y to skip confirm)?\n-&gt; vcpkg::zlib\nplease input: y (y/n)\n\n=&gt; install vcpkg::zlib .. ok\n[ 25%]: compiling.release src\\main.cpp\n[ 50%]: linking.release test\n[100%]: build ok!\n</code></pre>\n<h4>XMake 和 Conan</h4>\n<p>接下来是集成 Conan 的包，完全一样的方式，仅仅执行换个包管理器名字。</p>\n<pre><code class=\"language-lua\">add_requires(\"conan::zlib\", {alias = \"zlib\"})\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_packages(\"zlib\")\n</code></pre>\n<p>XMake 同样会自动安装 conan 中的 zlib 包，然后自动集成编译。</p>\n<h4>XMake 自建包管理</h4>\n<p>XMake 跟 CMake 还有其他构建系统，最大的不同点，也就是最大的优势之一，就是它有完全自建的包管理系统，我们完全可以不依赖 vcpkg/conan，也可以快速集成依赖包，比如：</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib 1.2.x\", \"tbox &gt;= 1.6.0\")\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_packages(\"zlib\", \"tbox\")\n</code></pre>\n<p>而且，它还支持完整的语义版本选择，多平台的包集成，交叉编译工具链的包集成，甚至编译工具链包的自动拉取使用。</p>\n<p>不仅如此，我们开可以对定制化配置对自建包的依赖，例如：</p>\n<h5>使用调式版本依赖包</h5>\n<p>我们可以使用 debug 版本库，实现对依赖库的断点调试。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {debug = true})\n</code></pre>\n<h5>设置 msvc 运行时库</h5>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {configs = {vs_runtime = \"MD\"}})\n</code></pre>\n<h5>使用动态库</h5>\n<p>默认集成的是静态库，我们也可以切换到动态库。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {configs = {shared = true}})\n</code></pre>\n<h5>语义版本支持</h5>\n<p>XMake 的自建包集成支持完整的版本语义规范。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib 1.2.x\")\nadd_requires(\"zlib &gt;=1.2.10\")\nadd_requires(\"zlib ~1.2.0\")\n</code></pre>\n<h5>禁止使用系统库</h5>\n<p>默认情况下，如果版本匹配，XMake 会优先查找使用系统上用户已经安装的库，当然我们也可以强制禁止查找使用系统库，仅仅从自建包仓库中下载安装包。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {system = true})\n</code></pre>\n<h5>可选依赖包</h5>\n<p>如果依赖包集成失败，XMake 会自动报错，中断编译，提示用户：<code>zlib not found</code>，但是我们也可以设置为可选包集成，这样的话，即使库最终没安装成功，也不影响项目的编译，仅仅只是跳过这个依赖。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {optional = true})\n</code></pre>\n<h5>包的定制化配置</h5>\n<p>比如，集成使用开启了 context/coroutine 模块配置的 boost 库。</p>\n<pre><code class=\"language-lua\">add_requires(\"boost\", {configs = {context = true, coroutine = true}})\n</code></pre>\n<h4>支持的包管理仓库</h4>\n<p>XMake 除了支持 vcpkg/conan 还有自建仓库的包集成支持，还支持其他的包管理仓库，例如：Conda/Homebrew/Apt/Pacman/Clib/Dub 等等，而且集成方式完全一致。</p>\n<p>用户可与快速切换使用其他的仓库包，而不需要花太多时间去研究如何集成它们。</p>\n<p>因此，XMake 并没有破坏 C/C++ 生态，而是极大的复用现有 C/C++ 生态的基础上，努力改进用户对 C/C++ 依赖包的使用体验，提高开发效率，让用户能够拥有更多的时间去关注项目本身。</p>\n<ul>\n<li>官方自建仓库 <a href=\"https://github.com/xmake-io/xmake-repo\" rel=\"nofollow\">xmake-repo</a> (tbox &gt;1.6.1)</li>\n<li>官方包管理器 <a href=\"https://github.com/xmake-io/xrepo\" rel=\"nofollow\">Xrepo</a></li>\n<li><a href=\"https://xmake.io/#/zh-cn/package/remote_package?id=%e4%bd%bf%e7%94%a8%e8%87%aa%e5%bb%ba%e7%a7%81%e6%9c%89%e5%8c%85%e4%bb%93%e5%ba%93\" rel=\"nofollow\">用户自建仓库</a></li>\n<li>Conan (conan::openssl/1.1.1g)</li>\n<li>Conda (conda::libpng 1.3.67)</li>\n<li>Vcpkg (vcpkg:ffmpeg)</li>\n<li>Homebrew/Linuxbrew (brew::pcre2/libpcre2-8)</li>\n<li>Pacman on archlinux/msys2 (pacman::libcurl)</li>\n<li>Apt on ubuntu/debian (apt::zlib1g-dev)</li>\n<li>Clib (clib::clibs/bytes@0.0.4)</li>\n<li>Dub (dub::log 0.4.3)</li>\n</ul>\n<h4>独立的包管理命令（ Xrepo ）</h4>\n<p>为了方便 XMake 的自建仓库中的包管理，以及第三方包的管理使用，我们也提供了独立的 Xrepo cli 命令工具，来方便的管理我们的依赖包</p>\n<p>我们可以使用这个工具，快速方便的完成下面的管理操作：</p>\n<ul>\n<li>安装包：<code>xrepo install zlib</code></li>\n<li>卸载包：<code>xrepo remove zlib</code></li>\n<li>获取包信息：<code>xrepo info zlib</code></li>\n<li>获取包编译链接 flags：<code>xrepo fetch zlib</code></li>\n<li>加载包虚拟 Shell 环境：<code>xrepo env shell</code> （这是一个很强大的特性）</li>\n</ul>\n<p>我们可以到 <a href=\"https://github.com/xmake-io/xrepo\" rel=\"nofollow\">Xrepo 项目主页</a> 查看更多的介绍和使用方式。</p>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://xrepo.xmake.io/assets/img/xrepo.gif\"/></p>\n<h3>轻量无依赖</h3>\n<p>使用 Meson/Scons 需要先安装 python/pip，使用 Bazel 需要先安装 java 等运行时环境，而 XMake 不需要额外安装任何依赖库和环境，自身安装包仅仅 2-3M，非常的轻量。</p>\n<p>尽管 XMake 是基于 lua，但是借助于 lua 胶水语言的轻量级特性，xmake 已将其完全内置，因此安装完 XMake 等同于拥有了一个完整的 lua vm 。</p>\n<p>有人会说，编译工具链总还是需要的吧，也不完全是，Windows 上，我们提供了预编译安装包，可以直接下载安装编译，地址见：<a href=\"https://github.com/xmake-io/xmake/releases\" rel=\"nofollow\">Releases</a></p>\n<p>另外，XMake 还支持远程拉取编译工具链，因此即使你的系统环境，还没有安装任何编译器，也没关系，用户完全不用考虑如何折腾编译环境，只需要在 xmake.lua 里面配置上需要的工具链即可。</p>\n<p>比如，我们在 Windows 上使用 mingw-w64 工具链来编译 C/C++ 工程，只需要做如下配置即可。</p>\n<pre><code class=\"language-lua\">add_requires(\"mingw-w64\")\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    set_toolchains(\"mingw@mingw-w64\")\n</code></pre>\n<p>通过 <code>set_toolchains</code> 配置绑定 mingw-w64 工具链包后，XMake 就会自动检测当前系统是否存在 mingw-64，如果还没安装，它会自动下载安装，然后完成项目编译，整个过程，用户仅仅只需要执行 <code>xmake</code> 这个命令就能完成。</p>\n<pre><code class=\"language-bash\">$ xmake\nnote: try installing these packages (pass -y to skip confirm)?\nin xmake-repo:\n-&gt; mingw-w64 8.1.0 [vs_runtime:MT]\nplease input: y (y/n)\n\n=&gt; download https://jaist.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z .. ok\nchecking for mingw directory ... C:\\Users\\ruki\\AppData\\Local\\.xmake\\packages\\m\\mingw-w64\\8.1.0\\aad6257977e0449595004d7441358fc5\n[ 25%]: compiling.release src\\main.cpp\n[ 50%]: linking.release test.exe\n[100%]: build ok!\n</code></pre>\n<p>除了 mingw-w64，我们还可以配置远程拉取使用其他的工具链，甚至交叉编译工具链，例如：llvm-mingw, llvm, tinycc, muslcc, gnu-rm, zig 等等。</p>\n<p>如果大家还想进一步了解远程工具链的拉取集成，可以看下文档：<a href=\"https://xmake.io/#/zh-cn/package/remote_package?id=%e8%87%aa%e5%8a%a8%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%b7%a5%e5%85%b7%e9%93%be\" rel=\"nofollow\">自动拉取远程工具链</a>。</p>\n<h3>极速并行编译</h3>\n<p>大家都知道 Ninja 构建非常快，因此很多人都喜欢用 CMake/Meson 生成 build.ninja  后，使用 Ninja 来满足极速构建的需求。</p>\n<p>尽管 Ninja 很快，但是我们还是需要先通过 meson.build 和 CMakelist.txt 文件生成 build.ninja 才行，这个生成过程也会占用几秒甚至十几秒的时间。</p>\n<p>而 XMake 不仅仅拥有和 Ninja 近乎相同的构建速度，而且不需要额外再生成其他构建文件，直接内置构建系统，任何情况下，只需要一个 <code>xmake</code> 命令就可以实现极速编译。</p>\n<p>我们也做过一些对比测试数据，供大家参考：</p>\n<h4>多任务并行编译测试</h4>\n<table>\n<thead>\n<tr>\n<th>构建系统</th>\n<th>Termux (8core/-j12)</th>\n<th>构建系统</th>\n<th>MacOS (8core/-j12)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>xmake</td>\n<td>24.890s</td>\n<td>xmake</td>\n<td>12.264s</td>\n</tr>\n<tr>\n<td>ninja</td>\n<td>25.682s</td>\n<td>ninja</td>\n<td>11.327s</td>\n</tr>\n<tr>\n<td>cmake(gen+make)</td>\n<td>5.416s+28.473s</td>\n<td>cmake(gen+make)</td>\n<td>1.203s+14.030s</td>\n</tr>\n<tr>\n<td>cmake(gen+ninja)</td>\n<td>4.458s+24.842s</td>\n<td>cmake(gen+ninja)</td>\n<td>0.988s+11.644s</td>\n</tr>\n</tbody></table><h4>单任务编译测试</h4>\n<table>\n<thead>\n<tr>\n<th>构建系统</th>\n<th>Termux (-j1)</th>\n<th>构建系统</th>\n<th>MacOS (-j1)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>xmake</td>\n<td>1m57.707s</td>\n<td>xmake</td>\n<td>39.937s</td>\n</tr>\n<tr>\n<td>ninja</td>\n<td>1m52.845s</td>\n<td>ninja</td>\n<td>38.995s</td>\n</tr>\n<tr>\n<td>cmake(gen+make)</td>\n<td>5.416s+2m10.539s</td>\n<td>cmake(gen+make)</td>\n<td>1.203s+41.737s</td>\n</tr>\n<tr>\n<td>cmake(gen+ninja)</td>\n<td>4.458s+1m54.868s</td>\n<td>cmake(gen+ninja)</td>\n<td>0.988s+38.022s</td>\n</tr>\n</tbody></table><h3>傻瓜式多平台编译</h3>\n<p>XMake 的另外一个特点，就是高效简单的多平台编译，不管你是编译 windows/linux/macOS 下的程序，还是编译 iphoneos/android 又或者是交叉编译。</p>\n<p>编译的配置方式大同小异，不必让用户去这折腾研究各个平台下如何去编译。</p>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://xmake.io/assets/img/index/xmake-basic-render.gif\"/></p>\n<h4>编译本机 Windows/Linux/MacOS  程序</h4>\n<p>当前本机程序编译，我们仅仅只需要执行：</p>\n<pre><code class=\"language-bash\">$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ cmake --build ..\n</code></pre>\n<h4>编译 Android 程序</h4>\n<pre><code class=\"language-bash\">$ xmake f -p android --ndk=~/android-ndk-r21e\n$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ cmake -DCMAKE_TOOLCHAIN_FILE=~/android-ndk-r21e/build/cmake/android.toolchain.cmake ..\n$ make\n</code></pre>\n<h4>编译 iOS 程序</h4>\n<pre><code class=\"language-bash\">$ xmake f -p iphoneos\n$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ wget https://raw.githubusercontent.com/leetal/ios-cmake/master/ios.toolchain.cmake\n$ cmake -DCMAKE_TOOLCHAIN_FILE=`pwd`/ios.toolchain.cmake ..\n$ make\n</code></pre>\n<p>我没有找到很方便的方式去配置编译 ios 程序，仅仅只能从其他地方找到一个第三方的 ios 工具链去配置编译。</p>\n<h4>交叉编译</h4>\n<p>我们通常只需要设置交叉编译工具链根目录，XMake 会自动检测工具链结构，提取里面的编译器参与编译，不需要额外配置什么。</p>\n<pre><code class=\"language-bash\">$ xmake f -p cross --sdk=~/aarch64-linux-musl-cross\n$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<p>我们需要先额外写一个 cross-toolchain.cmake 的交叉工具链配置文件。</p>\n<pre><code class=\"language-cmake\">set(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR aarch64)\n\nset(TOOL_CHAIN_DIR ~/aarch64-linux-musl)\nset(TOOL_CHAIN_INCLUDE ${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\nset(TOOL_CHAIN_LIB ${TOOL_CHAIN_DIR}/aarch64-linux-musl/lib)\n\nset(CMAKE_C_COMPILER \"aarch64-linux-gcc\")\nset(CMAKE_CXX_COMPILER \"aarch64-linux-g++\")\n\nset(CMAKE_FIND_ROOT_PATH ${TOOL_CHAIN_DIR}/aarch64-linux-musl)\n\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n\ninclude_directories(${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\nset(CMAKE_INCLUDE_PATH ${TOOL_CHAIN_INCLUDE})\nset(CMAKE_LIBRARY_PATH ${TOOL_CHAIN_LIB})\n</code></pre>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ cmake -DCMAKE_TOOLCHAIN_FILE=../cross-toolchain.cmake ..\n$ make\n</code></pre>\n<h3>结语</h3>\n<p>如果你是 C/C++ 开发的新手，可以通过 XMake 快速上手入门 C/C++ 编译构建。</p>\n<p>如果你想开发维护跨平台 C/C++ 项目，也可以考虑使用 XMake 来维护构建，提高开发效率，让你更加专注于项目本身，不再为折腾移植依赖库而烦恼。</p>\n<p>欢迎关注 XMake 项目：</p>\n<ul>\n<li><a href=\"https://github.com/xmake-io/xmake/\" rel=\"nofollow\">Github 项目地址</a></li>\n<li><a href=\"https://xmake.io/#/\" rel=\"nofollow\">项目主页</a></li>\n<li><a href=\"https://github.com/xmake-io/xmake-repo\" rel=\"nofollow\">XMake 包管理仓库</a></li>\n<li>\n社区<ul>\n<li><a href=\"https://t.me/tbooxorg\" rel=\"nofollow\">Telegram 群组</a></li>\n<li><a href=\"https://discord.gg/xmake\" rel=\"nofollow\">Discord 聊天室</a></li>\n<li>QQ 群：343118190, 662147501</li>\n<li>微信公众号：tboox-os</li>\n</ul>\n</li>\n<li>课程：<a href=\"https://xmake.io/#/zh-cn/about/course\" rel=\"nofollow\">Xmake 带你轻松构建 C/C++ 项目</a></li>\n<li>活动：<a href=\"https://tboox.org/cn/2021/04/29/xmake-summer-ospp/\" rel=\"nofollow\">开源之夏 &amp; Xmake</a></li>\n</ul>\n", "last_modified": 1620259117, "replies": 35, "id": 775065}]